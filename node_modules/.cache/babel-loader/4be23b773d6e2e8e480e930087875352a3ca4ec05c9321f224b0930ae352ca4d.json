{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CancellationToken = exports.TypedEventEmitter = exports.BSONType = void 0;\nconst events_1 = require(\"events\");\n/** @public */\nexports.BSONType = Object.freeze({\n  double: 1,\n  string: 2,\n  object: 3,\n  array: 4,\n  binData: 5,\n  undefined: 6,\n  objectId: 7,\n  bool: 8,\n  date: 9,\n  null: 10,\n  regex: 11,\n  dbPointer: 12,\n  javascript: 13,\n  symbol: 14,\n  javascriptWithScope: 15,\n  int: 16,\n  timestamp: 17,\n  long: 18,\n  decimal: 19,\n  minKey: -1,\n  maxKey: 127\n});\n/**\n * Typescript type safe event emitter\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass TypedEventEmitter extends events_1.EventEmitter {}\nexports.TypedEventEmitter = TypedEventEmitter;\n/** @public */\nclass CancellationToken extends TypedEventEmitter {}\nexports.CancellationToken = CancellationToken;","map":{"version":3,"mappings":";;;;;;AAWA;AAkIA;AACaA,gBAAQ,GAAGC,MAAM,CAACC,MAAM,CAAC;EACpCC,MAAM,EAAE,CAAC;EACTC,MAAM,EAAE,CAAC;EACTC,MAAM,EAAE,CAAC;EACTC,KAAK,EAAE,CAAC;EACRC,OAAO,EAAE,CAAC;EACVC,SAAS,EAAE,CAAC;EACZC,QAAQ,EAAE,CAAC;EACXC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,EAAE;EACRC,KAAK,EAAE,EAAE;EACTC,SAAS,EAAE,EAAE;EACbC,UAAU,EAAE,EAAE;EACdC,MAAM,EAAE,EAAE;EACVC,mBAAmB,EAAE,EAAE;EACvBC,GAAG,EAAE,EAAE;EACPC,SAAS,EAAE,EAAE;EACbC,IAAI,EAAE,EAAE;EACRC,OAAO,EAAE,EAAE;EACXC,MAAM,EAAE,CAAC,CAAC;EACVC,MAAM,EAAE;CACA,CAAC;AA8PX;;;;AAIA;AACA,MAAaC,iBAAoD,SAAQC,qBAAY;AAArFzB;AAEA;AACA,MAAa0B,iBAAkB,SAAQF,iBAAqC;AAA5ExB","names":["exports","Object","freeze","double","string","object","array","binData","undefined","objectId","bool","date","null","regex","dbPointer","javascript","symbol","javascriptWithScope","int","timestamp","long","decimal","minKey","maxKey","TypedEventEmitter","events_1","CancellationToken"],"sources":["C:\\Users\\danin\\node_modules\\mongodb\\src\\mongo_types.ts"],"sourcesContent":["import type {\n  Binary,\n  Document,\n  ObjectId,\n  BSONRegExp,\n  Timestamp,\n  Decimal128,\n  Double,\n  Int32,\n  Long\n} from './bson';\nimport { EventEmitter } from 'events';\nimport type { Sort } from './sort';\n\n/** @internal */\nexport type TODO_NODE_3286 = any;\n\n/** Given an object shaped type, return the type of the _id field or default to ObjectId @public */\nexport type InferIdType<TSchema> = TSchema extends { _id: infer IdType } // user has defined a type for _id\n  ? // eslint-disable-next-line @typescript-eslint/ban-types\n    {} extends IdType // TODO(NODE-3285): Improve type readability\n    ? // eslint-disable-next-line @typescript-eslint/ban-types\n      Exclude<IdType, {}>\n    : unknown extends IdType\n    ? ObjectId\n    : IdType\n  : ObjectId; // user has not defined _id on schema\n\n/** Add an _id field to an object shaped type @public */\nexport type WithId<TSchema> = EnhancedOmit<TSchema, '_id'> & { _id: InferIdType<TSchema> };\n\n/**\n * Add an optional _id field to an object shaped type\n * @public\n *\n * @privateRemarks\n * `ObjectId extends TSchema['_id']` is a confusing ordering at first glance. Rather than ask\n * `TSchema['_id'] extends ObjectId` which translated to \"Is the _id property ObjectId?\"\n * we instead ask \"Does ObjectId look like (have the same shape) as the _id?\"\n */\nexport type OptionalId<TSchema extends { _id?: any }> = ObjectId extends TSchema['_id'] // a Schema with ObjectId _id type or \"any\" or \"indexed type\" provided\n  ? EnhancedOmit<TSchema, '_id'> & { _id?: InferIdType<TSchema> } // a Schema provided but _id type is not ObjectId\n  : WithId<TSchema>; // TODO(NODE-3285): Improve type readability\n\n/** TypeScript Omit (Exclude to be specific) does not work for objects with an \"any\" indexed type, and breaks discriminated unions @public */\nexport type EnhancedOmit<TRecordOrUnion, KeyUnion> = string extends keyof TRecordOrUnion\n  ? TRecordOrUnion // TRecordOrUnion has indexed type e.g. { _id: string; [k: string]: any; } or it is \"any\"\n  : TRecordOrUnion extends any\n  ? Pick<TRecordOrUnion, Exclude<keyof TRecordOrUnion, KeyUnion>> // discriminated unions\n  : never;\n\n/** Remove the _id field from an object shaped type @public */\nexport type WithoutId<TSchema> = Omit<TSchema, '_id'>;\n\n/** A MongoDB filter can be some portion of the schema or a set of operators @public */\nexport type Filter<TSchema> = {\n  [P in keyof TSchema]?: Condition<TSchema[P]>;\n} &\n  RootFilterOperators<TSchema>;\n\n/** @public */\nexport type Condition<T> = AlternativeType<T> | FilterOperators<AlternativeType<T>>;\n\n/**\n * It is possible to search using alternative types in mongodb e.g.\n * string types can be searched using a regex in mongo\n * array types can be searched using their element type\n * @public\n */\nexport type AlternativeType<T> = T extends ReadonlyArray<infer U>\n  ? T | RegExpOrString<U>\n  : RegExpOrString<T>;\n\n/** @public */\nexport type RegExpOrString<T> = T extends string ? BSONRegExp | RegExp | T : T;\n\n/** @public */\nexport interface RootFilterOperators<TSchema> extends Document {\n  $and?: Filter<TSchema>[];\n  $nor?: Filter<TSchema>[];\n  $or?: Filter<TSchema>[];\n  $text?: {\n    $search: string;\n    $language?: string;\n    $caseSensitive?: boolean;\n    $diacriticSensitive?: boolean;\n  };\n  $where?: string | ((this: TSchema) => boolean);\n  $comment?: string | Document;\n}\n\n/** @public */\nexport interface FilterOperators<TValue> extends Document {\n  // Comparison\n  $eq?: TValue;\n  $gt?: TValue;\n  $gte?: TValue;\n  $in?: ReadonlyArray<TValue>;\n  $lt?: TValue;\n  $lte?: TValue;\n  $ne?: TValue;\n  $nin?: ReadonlyArray<TValue>;\n  // Logical\n  $not?: TValue extends string ? FilterOperators<TValue> | RegExp : FilterOperators<TValue>;\n  // Element\n  /**\n   * When `true`, `$exists` matches the documents that contain the field,\n   * including documents where the field value is null.\n   */\n  $exists?: boolean;\n  $type?: BSONType | BSONTypeAlias;\n  // Evaluation\n  $expr?: Record<string, any>;\n  $jsonSchema?: Record<string, any>;\n  $mod?: TValue extends number ? [number, number] : never;\n  $regex?: TValue extends string ? RegExp | BSONRegExp | string : never;\n  $options?: TValue extends string ? string : never;\n  // Geospatial\n  $geoIntersects?: { $geometry: Document };\n  $geoWithin?: Document;\n  $near?: Document;\n  $nearSphere?: Document;\n  $maxDistance?: number;\n  // Array\n  $all?: ReadonlyArray<any>;\n  $elemMatch?: Document;\n  $size?: TValue extends ReadonlyArray<any> ? number : never;\n  // Bitwise\n  $bitsAllClear?: BitwiseFilter;\n  $bitsAllSet?: BitwiseFilter;\n  $bitsAnyClear?: BitwiseFilter;\n  $bitsAnySet?: BitwiseFilter;\n  $rand?: Record<string, never>;\n}\n\n/** @public */\nexport type BitwiseFilter =\n  | number /** numeric bit mask */\n  | Binary /** BinData bit mask */\n  | ReadonlyArray<number>; /** `[ <position1>, <position2>, ... ]` */\n\n/** @public */\nexport const BSONType = Object.freeze({\n  double: 1,\n  string: 2,\n  object: 3,\n  array: 4,\n  binData: 5,\n  undefined: 6,\n  objectId: 7,\n  bool: 8,\n  date: 9,\n  null: 10,\n  regex: 11,\n  dbPointer: 12,\n  javascript: 13,\n  symbol: 14,\n  javascriptWithScope: 15,\n  int: 16,\n  timestamp: 17,\n  long: 18,\n  decimal: 19,\n  minKey: -1,\n  maxKey: 127\n} as const);\n\n/** @public */\nexport type BSONType = typeof BSONType[keyof typeof BSONType];\n/** @public */\nexport type BSONTypeAlias = keyof typeof BSONType;\n\n/**\n * @public\n * Projection is flexible to permit the wide array of aggregation operators\n * @deprecated since v4.1.0: Since projections support all aggregation operations we have no plans to narrow this type further\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type Projection<TSchema extends Document = Document> = Document;\n\n/**\n * @public\n * @deprecated since v4.1.0: Since projections support all aggregation operations we have no plans to narrow this type further\n */\nexport type ProjectionOperators = Document;\n\n/** @public */\nexport type IsAny<Type, ResultIfAny, ResultIfNotAny> = true extends false & Type\n  ? ResultIfAny\n  : ResultIfNotAny;\n\n/** @public */\nexport type Flatten<Type> = Type extends ReadonlyArray<infer Item> ? Item : Type;\n\n/** @public */\nexport type SchemaMember<T, V> = { [P in keyof T]?: V } | { [key: string]: V };\n\n/** @public */\nexport type IntegerType = number | Int32 | Long;\n\n/** @public */\nexport type NumericType = IntegerType | Decimal128 | Double;\n\n/** @public */\nexport type FilterOperations<T> = T extends Record<string, any>\n  ? { [key in keyof T]?: FilterOperators<T[key]> }\n  : FilterOperators<T>;\n\n/** @public */\nexport type KeysOfAType<TSchema, Type> = {\n  [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? key : never;\n}[keyof TSchema];\n\n/** @public */\nexport type KeysOfOtherType<TSchema, Type> = {\n  [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? never : key;\n}[keyof TSchema];\n\n/** @public */\nexport type AcceptedFields<TSchema, FieldType, AssignableType> = {\n  readonly [key in KeysOfAType<TSchema, FieldType>]?: AssignableType;\n};\n\n/** It avoids using fields with not acceptable types @public */\nexport type NotAcceptedFields<TSchema, FieldType> = {\n  readonly [key in KeysOfOtherType<TSchema, FieldType>]?: never;\n};\n\n/** @public */\nexport type OnlyFieldsOfType<TSchema, FieldType = any, AssignableType = FieldType> = IsAny<\n  TSchema[keyof TSchema],\n  Record<string, FieldType>,\n  AcceptedFields<TSchema, FieldType, AssignableType> &\n    NotAcceptedFields<TSchema, FieldType> &\n    Record<string, AssignableType>\n>;\n\n/** @public */\nexport type MatchKeysAndValues<TSchema> = Readonly<Partial<TSchema>> & Record<string, any>;\n\n/** @public */\nexport type AddToSetOperators<Type> = {\n  $each?: Array<Flatten<Type>>;\n};\n\n/** @public */\nexport type ArrayOperator<Type> = {\n  $each?: Array<Flatten<Type>>;\n  $slice?: number;\n  $position?: number;\n  $sort?: Sort;\n};\n\n/** @public */\nexport type SetFields<TSchema> = ({\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any> | undefined>]?:\n    | OptionalId<Flatten<TSchema[key]>>\n    | AddToSetOperators<Array<OptionalId<Flatten<TSchema[key]>>>>;\n} &\n  NotAcceptedFields<TSchema, ReadonlyArray<any> | undefined>) & {\n  readonly [key: string]: AddToSetOperators<any> | any;\n};\n\n/** @public */\nexport type PushOperator<TSchema> = ({\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:\n    | Flatten<TSchema[key]>\n    | ArrayOperator<Array<Flatten<TSchema[key]>>>;\n} &\n  NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\n  readonly [key: string]: ArrayOperator<any> | any;\n};\n\n/** @public */\nexport type PullOperator<TSchema> = ({\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:\n    | Partial<Flatten<TSchema[key]>>\n    | FilterOperations<Flatten<TSchema[key]>>;\n} &\n  NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\n  readonly [key: string]: FilterOperators<any> | any;\n};\n\n/** @public */\nexport type PullAllOperator<TSchema> = ({\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: TSchema[key];\n} &\n  NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\n  readonly [key: string]: ReadonlyArray<any>;\n};\n\n/** @public */\nexport type UpdateFilter<TSchema> = {\n  $currentDate?: OnlyFieldsOfType<\n    TSchema,\n    Date | Timestamp,\n    true | { $type: 'date' | 'timestamp' }\n  >;\n  $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $min?: MatchKeysAndValues<TSchema>;\n  $max?: MatchKeysAndValues<TSchema>;\n  $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $rename?: Record<string, string>;\n  $set?: MatchKeysAndValues<TSchema>;\n  $setOnInsert?: MatchKeysAndValues<TSchema>;\n  $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;\n  $addToSet?: SetFields<TSchema>;\n  $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;\n  $pull?: PullOperator<TSchema>;\n  $push?: PushOperator<TSchema>;\n  $pullAll?: PullAllOperator<TSchema>;\n  $bit?: OnlyFieldsOfType<\n    TSchema,\n    NumericType | undefined,\n    { and: IntegerType } | { or: IntegerType } | { xor: IntegerType }\n  >;\n} & Document;\n\n/** @public */\nexport type Nullable<AnyType> = AnyType | null | undefined;\n\n/** @public */\nexport type OneOrMore<T> = T | ReadonlyArray<T>;\n\n/** @public */\nexport type GenericListener = (...args: any[]) => void;\n\n/**\n * Event description type\n * @public\n */\nexport type EventsDescription = Record<string, GenericListener>;\n\n/** @public */\nexport type CommonEvents = 'newListener' | 'removeListener';\n\n/**\n * Typescript type safe event emitter\n * @public\n */\nexport declare interface TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {\n  addListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  addListener(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  addListener(event: string | symbol, listener: GenericListener): this;\n\n  on<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  on(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  on(event: string | symbol, listener: GenericListener): this;\n\n  once<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  once(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  once(event: string | symbol, listener: GenericListener): this;\n\n  removeListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  removeListener(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  removeListener(event: string | symbol, listener: GenericListener): this;\n\n  off<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  off(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  off(event: string | symbol, listener: GenericListener): this;\n\n  removeAllListeners<EventKey extends keyof Events>(\n    event?: EventKey | CommonEvents | symbol | string\n  ): this;\n\n  listeners<EventKey extends keyof Events>(\n    event: EventKey | CommonEvents | symbol | string\n  ): Events[EventKey][];\n\n  rawListeners<EventKey extends keyof Events>(\n    event: EventKey | CommonEvents | symbol | string\n  ): Events[EventKey][];\n\n  emit<EventKey extends keyof Events>(\n    event: EventKey | symbol,\n    ...args: Parameters<Events[EventKey]>\n  ): boolean;\n\n  listenerCount<EventKey extends keyof Events>(\n    type: EventKey | CommonEvents | symbol | string\n  ): number;\n\n  prependListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  prependListener(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  prependListener(event: string | symbol, listener: GenericListener): this;\n\n  prependOnceListener<EventKey extends keyof Events>(\n    event: EventKey,\n    listener: Events[EventKey]\n  ): this;\n  prependOnceListener(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  prependOnceListener(event: string | symbol, listener: GenericListener): this;\n\n  eventNames(): string[];\n  getMaxListeners(): number;\n  setMaxListeners(n: number): this;\n}\n\n/**\n * Typescript type safe event emitter\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport class TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {}\n\n/** @public */\nexport class CancellationToken extends TypedEventEmitter<{ cancel(): void }> {}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}