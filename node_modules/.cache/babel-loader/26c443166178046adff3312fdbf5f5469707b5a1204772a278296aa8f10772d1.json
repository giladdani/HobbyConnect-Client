{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChangeStreamCursor = exports.ChangeStream = void 0;\nconst Denque = require(\"denque\");\nconst error_1 = require(\"./error\");\nconst aggregate_1 = require(\"./operations/aggregate\");\nconst utils_1 = require(\"./utils\");\nconst mongo_client_1 = require(\"./mongo_client\");\nconst db_1 = require(\"./db\");\nconst collection_1 = require(\"./collection\");\nconst abstract_cursor_1 = require(\"./cursor/abstract_cursor\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst mongo_types_1 = require(\"./mongo_types\");\n/** @internal */\nconst kResumeQueue = Symbol('resumeQueue');\n/** @internal */\nconst kCursorStream = Symbol('cursorStream');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kMode = Symbol('mode');\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(CHANGE_STREAM_OPTIONS);\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\nconst NO_RESUME_TOKEN_ERROR = 'A change stream document has been received that lacks a resume token (_id).';\nconst NO_CURSOR_ERROR = 'ChangeStream has no cursor';\nconst CHANGESTREAM_CLOSED_ERROR = 'ChangeStream is closed';\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @public\n */\nclass ChangeStream extends mongo_types_1.TypedEventEmitter {\n  /**\n   * @internal\n   *\n   * @param parent - The parent object that created this change stream\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n   */\n  constructor(parent) {\n    let pipeline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.pipeline = pipeline;\n    this.options = options;\n    if (parent instanceof collection_1.Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n    } else if (parent instanceof db_1.Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n    } else if (parent instanceof mongo_client_1.MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n    } else {\n      throw new error_1.MongoChangeStreamError('Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient');\n    }\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n    if (!this.options.readPreference && parent.readPreference) {\n      this.options.readPreference = parent.readPreference;\n    }\n    this[kResumeQueue] = new Denque();\n    // Create contained Change Stream cursor\n    this.cursor = createChangeStreamCursor(this, options);\n    this[kClosed] = false;\n    this[kMode] = false;\n    // Listen for any `change` listeners being added to ChangeStream\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        streamEvents(this, this.cursor);\n      }\n    });\n    this.on('removeListener', eventName => {\n      var _a;\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        (_a = this[kCursorStream]) === null || _a === void 0 ? void 0 : _a.removeAllListeners('data');\n      }\n    });\n  }\n  /** @internal */\n  get cursorStream() {\n    return this[kCursorStream];\n  }\n  /** The cached resume token that is used to resume after the most recently returned change. */\n  get resumeToken() {\n    var _a;\n    return (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.resumeToken;\n  }\n  /** Check if there is any document still available in the Change Stream */\n  hasNext(callback) {\n    setIsIterator(this);\n    return utils_1.maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        cursor.hasNext(cb);\n      });\n    });\n  }\n  next(callback) {\n    setIsIterator(this);\n    return utils_1.maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        cursor.next((error, change) => {\n          if (error) {\n            this[kResumeQueue].push(() => this.next(cb));\n            processError(this, error, cb);\n            return;\n          }\n          processNewChange(this, change, cb);\n        });\n      });\n    });\n  }\n  /** Is the cursor closed */\n  get closed() {\n    var _a, _b;\n    return this[kClosed] || ((_b = (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.closed) !== null && _b !== void 0 ? _b : false);\n  }\n  /** Close the Change Stream */\n  close(callback) {\n    this[kClosed] = true;\n    return utils_1.maybePromise(callback, cb => {\n      if (!this.cursor) {\n        return cb();\n      }\n      const cursor = this.cursor;\n      return cursor.close(err => {\n        endStream(this);\n        this.cursor = undefined;\n        return cb(err);\n      });\n    });\n  }\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @throws MongoDriverError if this.cursor is undefined\n   */\n  stream(options) {\n    this.streamOptions = options;\n    if (!this.cursor) throw new error_1.MongoChangeStreamError(NO_CURSOR_ERROR);\n    return this.cursor.stream(options);\n  }\n  tryNext(callback) {\n    setIsIterator(this);\n    return utils_1.maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        return cursor.tryNext(cb);\n      });\n    });\n  }\n}\nexports.ChangeStream = ChangeStream;\n/** @event */\nChangeStream.RESPONSE = 'response';\n/** @event */\nChangeStream.MORE = 'more';\n/** @event */\nChangeStream.INIT = 'init';\n/** @event */\nChangeStream.CLOSE = 'close';\n/**\n * Fired for each new matching change in the specified namespace. Attaching a `change`\n * event listener to a Change Stream will switch the stream into flowing mode. Data will\n * then be passed as soon as it is available.\n * @event\n */\nChangeStream.CHANGE = 'change';\n/** @event */\nChangeStream.END = 'end';\n/** @event */\nChangeStream.ERROR = 'error';\n/**\n * Emitted each time the change stream stores a new resume token.\n * @event\n */\nChangeStream.RESUME_TOKEN_CHANGED = 'resumeTokenChanged';\n/** @internal */\nclass ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(topology, namespace) {\n    let pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(topology, namespace, options);\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit(ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n  get resumeToken() {\n    return this._resumeToken;\n  }\n  get resumeOptions() {\n    const result = {};\n    for (const optionName of CURSOR_OPTIONS) {\n      if (Reflect.has(this.options, optionName)) {\n        Reflect.set(result, optionName, Reflect.get(this.options, optionName));\n      }\n    }\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => Reflect.deleteProperty(result, key));\n      if (this.resumeToken) {\n        const resumeKey = this.options.startAfter && !this.hasReceived ? 'startAfter' : 'resumeAfter';\n        Reflect.set(result, resumeKey, this.resumeToken);\n      } else if (this.startAtOperationTime && utils_1.maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n    return result;\n  }\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n  _processBatch(batchName, response) {\n    const cursor = (response === null || response === void 0 ? void 0 : response.cursor) || {};\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = cursor.postBatchResumeToken;\n      if (cursor[batchName].length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n  clone() {\n    return new ChangeStreamCursor(this.topology, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    execute_operation_1.executeOperation(this.topology, aggregateOperation, (err, response) => {\n      if (err || response == null) {\n        return callback(err);\n      }\n      const server = aggregateOperation.server;\n      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && utils_1.maxWireVersion(server) >= 7) {\n        this.startAtOperationTime = response.operationTime;\n      }\n      this._processBatch('firstBatch', response);\n      this.emit(ChangeStream.INIT, response);\n      this.emit(ChangeStream.RESPONSE);\n      // TODO: NODE-2882\n      callback(undefined, {\n        server,\n        session,\n        response\n      });\n    });\n  }\n  _getMore(batchSize, callback) {\n    super._getMore(batchSize, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n      this._processBatch('nextBatch', response);\n      this.emit(ChangeStream.MORE, response);\n      this.emit(ChangeStream.RESPONSE);\n      callback(err, response);\n    });\n  }\n}\nexports.ChangeStreamCursor = ChangeStreamCursor;\nconst CHANGE_STREAM_EVENTS = [ChangeStream.RESUME_TOKEN_CHANGED, ChangeStream.END, ChangeStream.CLOSE];\nfunction setIsEmitter(changeStream) {\n  if (changeStream[kMode] === 'iterator') {\n    // TODO(NODE-3485): Replace with MongoChangeStreamModeError\n    throw new error_1.MongoAPIError('ChangeStream cannot be used as an EventEmitter after being used as an iterator');\n  }\n  changeStream[kMode] = 'emitter';\n}\nfunction setIsIterator(changeStream) {\n  if (changeStream[kMode] === 'emitter') {\n    // TODO(NODE-3485): Replace with MongoChangeStreamModeError\n    throw new error_1.MongoAPIError('ChangeStream cannot be used as an iterator after being used as an EventEmitter');\n  }\n  changeStream[kMode] = 'iterator';\n}\n/**\n * Create a new change stream cursor based on self's configuration\n * @internal\n */\nfunction createChangeStreamCursor(changeStream, options) {\n  const changeStreamStageOptions = {\n    fullDocument: options.fullDocument || 'default'\n  };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n  if (changeStream.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n  const pipeline = [{\n    $changeStream: changeStreamStageOptions\n  }].concat(changeStream.pipeline);\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor(utils_1.getTopology(changeStream.parent), changeStream.namespace, pipeline, cursorOptions);\n  for (const event of CHANGE_STREAM_EVENTS) {\n    changeStreamCursor.on(event, e => changeStream.emit(event, e));\n  }\n  if (changeStream.listenerCount(ChangeStream.CHANGE) > 0) {\n    streamEvents(changeStream, changeStreamCursor);\n  }\n  return changeStreamCursor;\n}\nfunction applyKnownOptions(target, source, optionNames) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n  return target;\n}\n// This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\nconst SELECTION_TIMEOUT = 30000;\nfunction waitForTopologyConnected(topology, options, callback) {\n  setTimeout(() => {\n    if (options && options.start == null) {\n      options.start = utils_1.now();\n    }\n    const start = options.start || utils_1.now();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    if (topology.isConnected()) {\n      return callback();\n    }\n    if (utils_1.calculateDurationInMs(start) > timeout) {\n      // TODO(NODE-3497): Replace with MongoNetworkTimeoutError\n      return callback(new error_1.MongoRuntimeError('Timed out waiting for connection'));\n    }\n    waitForTopologyConnected(topology, options, callback);\n  }, 500); // this is an arbitrary wait time to allow SDAM to transition\n}\n\nfunction closeWithError(changeStream, error, callback) {\n  if (!callback) {\n    changeStream.emit(ChangeStream.ERROR, error);\n  }\n  changeStream.close(() => callback && callback(error));\n}\nfunction streamEvents(changeStream, cursor) {\n  setIsEmitter(changeStream);\n  const stream = changeStream[kCursorStream] || cursor.stream();\n  changeStream[kCursorStream] = stream;\n  stream.on('data', change => processNewChange(changeStream, change));\n  stream.on('error', error => processError(changeStream, error));\n}\nfunction endStream(changeStream) {\n  const cursorStream = changeStream[kCursorStream];\n  if (cursorStream) {\n    ['data', 'close', 'end', 'error'].forEach(event => cursorStream.removeAllListeners(event));\n    cursorStream.destroy();\n  }\n  changeStream[kCursorStream] = undefined;\n}\nfunction processNewChange(changeStream, change, callback) {\n  var _a;\n  if (changeStream[kClosed]) {\n    // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n    if (callback) callback(new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n  // a null change means the cursor has been notified, implicitly closing the change stream\n  if (change == null) {\n    // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n    return closeWithError(changeStream, new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR), callback);\n  }\n  if (change && !change._id) {\n    return closeWithError(changeStream, new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR), callback);\n  }\n  // cache the resume token\n  (_a = changeStream.cursor) === null || _a === void 0 ? void 0 : _a.cacheResumeToken(change._id);\n  // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n  changeStream.options.startAtOperationTime = undefined;\n  // Return the change\n  if (!callback) return changeStream.emit(ChangeStream.CHANGE, change);\n  return callback(undefined, change);\n}\nfunction processError(changeStream, error, callback) {\n  const cursor = changeStream.cursor;\n  // If the change stream has been closed explicitly, do not process error.\n  if (changeStream[kClosed]) {\n    // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n    if (callback) callback(new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n  // if the resume succeeds, continue with the new cursor\n  function resumeWithCursor(newCursor) {\n    changeStream.cursor = newCursor;\n    processResumeQueue(changeStream);\n  }\n  // otherwise, raise an error and close the change stream\n  function unresumableError(err) {\n    if (!callback) {\n      changeStream.emit(ChangeStream.ERROR, err);\n    }\n    changeStream.close(() => processResumeQueue(changeStream, err));\n  }\n  if (cursor && error_1.isResumableError(error, utils_1.maxWireVersion(cursor.server))) {\n    changeStream.cursor = undefined;\n    // stop listening to all events from old cursor\n    endStream(changeStream);\n    // close internal cursor, ignore errors\n    cursor.close();\n    const topology = utils_1.getTopology(changeStream.parent);\n    waitForTopologyConnected(topology, {\n      readPreference: cursor.readPreference\n    }, err => {\n      // if the topology can't reconnect, close the stream\n      if (err) return unresumableError(err);\n      // create a new cursor, preserving the old cursor's options\n      const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n      // attempt to continue in emitter mode\n      if (!callback) return resumeWithCursor(newCursor);\n      // attempt to continue in iterator mode\n      newCursor.hasNext(err => {\n        // if there's an error immediately after resuming, close the stream\n        if (err) return unresumableError(err);\n        resumeWithCursor(newCursor);\n      });\n    });\n    return;\n  }\n  // if initial error wasn't resumable, raise an error and close the change stream\n  return closeWithError(changeStream, error, callback);\n}\n/**\n * Safely provides a cursor across resume attempts\n *\n * @param changeStream - the parent ChangeStream\n */\nfunction getCursor(changeStream, callback) {\n  if (changeStream[kClosed]) {\n    // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n    callback(new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n  // if a cursor exists and it is open, return it\n  if (changeStream.cursor) {\n    callback(undefined, changeStream.cursor);\n    return;\n  }\n  // no cursor, queue callback until topology reconnects\n  changeStream[kResumeQueue].push(callback);\n}\n/**\n * Drain the resume queue when a new has become available\n *\n * @param changeStream - the parent ChangeStream\n * @param err - error getting a new cursor\n */\nfunction processResumeQueue(changeStream, err) {\n  while (changeStream[kResumeQueue].length) {\n    const request = changeStream[kResumeQueue].pop();\n    if (!request) break; // Should never occur but TS can't use the length check in the while condition\n    if (!err) {\n      if (changeStream[kClosed]) {\n        // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n        request(new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR));\n        return;\n      }\n      if (!changeStream.cursor) {\n        request(new error_1.MongoChangeStreamError(NO_CURSOR_ERROR));\n        return;\n      }\n    }\n    request(err, changeStream.cursor);\n  }\n}","map":{"version":3,"mappings":"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","names":["kResumeQueue","Symbol","kCursorStream","kClosed","kMode","CHANGE_STREAM_OPTIONS","CURSOR_OPTIONS","concat","CHANGE_DOMAIN_TYPES","COLLECTION","DATABASE","CLUSTER","NO_RESUME_TOKEN_ERROR","NO_CURSOR_ERROR","CHANGESTREAM_CLOSED_ERROR","ChangeStream","mongo_types_1","constructor","parent","pipeline","options","collection_1","type","db_1","mongo_client_1","error_1","namespace","s","readPreference","Denque","cursor","createChangeStreamCursor","on","eventName","listenerCount","streamEvents","removeAllListeners","cursorStream","resumeToken","hasNext","callback","setIsIterator","utils_1","cb","getCursor","err","next","error","change","push","processError","processNewChange","closed","close","endStream","undefined","stream","streamOptions","tryNext","exports","ChangeStreamCursor","abstract_cursor_1","topology","_resumeToken","startAtOperationTime","startAfter","resumeAfter","token","emit","RESUME_TOKEN_CHANGED","resumeOptions","result","optionName","Reflect","has","set","get","forEach","key","deleteProperty","resumeKey","hasReceived","server","cacheResumeToken","bufferedCount","postBatchResumeToken","_processBatch","batchName","response","length","clone","cursorOptions","_initialize","session","aggregateOperation","aggregate_1","execute_operation_1","operationTime","INIT","RESPONSE","_getMore","batchSize","MORE","CHANGE_STREAM_EVENTS","END","CLOSE","setIsEmitter","changeStream","changeStreamStageOptions","fullDocument","applyKnownOptions","allChangesForCluster","$changeStream","changeStreamCursor","event","e","CHANGE","target","source","optionNames","name","SELECTION_TIMEOUT","waitForTopologyConnected","setTimeout","start","timeout","isConnected","closeWithError","ERROR","destroy","_id","resumeWithCursor","newCursor","processResumeQueue","unresumableError","request","pop"],"sources":["C:\\Users\\danin\\node_modules\\mongodb\\src\\change_stream.ts"],"sourcesContent":["import Denque = require('denque');\nimport {\n  MongoError,\n  AnyError,\n  isResumableError,\n  MongoRuntimeError,\n  MongoAPIError,\n  MongoChangeStreamError\n} from './error';\nimport { AggregateOperation, AggregateOptions } from './operations/aggregate';\nimport {\n  maxWireVersion,\n  calculateDurationInMs,\n  now,\n  maybePromise,\n  MongoDBNamespace,\n  Callback,\n  getTopology\n} from './utils';\nimport type { ReadPreference } from './read_preference';\nimport type { Timestamp, Document } from './bson';\nimport type { Topology } from './sdam/topology';\nimport type { OperationParent, CollationOptions } from './operations/command';\nimport { MongoClient } from './mongo_client';\nimport { Db } from './db';\nimport { Collection } from './collection';\nimport type { Readable } from 'stream';\nimport {\n  AbstractCursor,\n  AbstractCursorEvents,\n  AbstractCursorOptions,\n  CursorStreamOptions\n} from './cursor/abstract_cursor';\nimport type { ClientSession } from './sessions';\nimport { executeOperation, ExecutionResult } from './operations/execute_operation';\nimport { InferIdType, Nullable, TypedEventEmitter } from './mongo_types';\n\n/** @internal */\nconst kResumeQueue = Symbol('resumeQueue');\n/** @internal */\nconst kCursorStream = Symbol('cursorStream');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kMode = Symbol('mode');\n\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(\n  CHANGE_STREAM_OPTIONS\n);\n\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\n\nconst NO_RESUME_TOKEN_ERROR =\n  'A change stream document has been received that lacks a resume token (_id).';\nconst NO_CURSOR_ERROR = 'ChangeStream has no cursor';\nconst CHANGESTREAM_CLOSED_ERROR = 'ChangeStream is closed';\n\n/** @public */\nexport interface ResumeOptions {\n  startAtOperationTime?: Timestamp;\n  batchSize?: number;\n  maxAwaitTimeMS?: number;\n  collation?: CollationOptions;\n  readPreference?: ReadPreference;\n}\n\n/**\n * Represents the logical starting point for a new or resuming {@link https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token| Change Stream} on the server.\n * @public\n */\nexport type ResumeToken = unknown;\n\n/**\n * Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\n * @public\n * @remarks\n * See {@link https://docs.mongodb.com/manual/reference/method/db.runCommand/#response| Run Command Response}\n */\nexport type OperationTime = Timestamp;\n\n/** @public */\nexport interface PipeOptions {\n  end?: boolean;\n}\n\n/**\n * Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\n * @public\n */\nexport interface ChangeStreamOptions extends AggregateOptions {\n  /** Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred. */\n  fullDocument?: string;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a change stream query. */\n  maxAwaitTimeMS?: number;\n  /** Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}. */\n  resumeAfter?: ResumeToken;\n  /** Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}. */\n  startAfter?: ResumeToken;\n  /** Will start the changeStream after the specified operationTime. */\n  startAtOperationTime?: OperationTime;\n  /** The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}. */\n  batchSize?: number;\n}\n\n/** @public */\nexport interface ChangeStreamDocument<TSchema extends Document = Document> {\n  /**\n   * The id functions as an opaque token for use when resuming an interrupted\n   * change stream.\n   */\n  _id: InferIdType<TSchema>;\n\n  /**\n   * Describes the type of operation represented in this change notification.\n   */\n  operationType:\n    | 'insert'\n    | 'update'\n    | 'replace'\n    | 'delete'\n    | 'invalidate'\n    | 'drop'\n    | 'dropDatabase'\n    | 'rename';\n\n  /**\n   * Contains two fields: “db” and “coll” containing the database and\n   * collection name in which the change happened.\n   */\n  ns: { db: string; coll: string };\n\n  /**\n   * Only present for ops of type ‘insert’, ‘update’, ‘replace’, and\n   * ‘delete’.\n   *\n   * For unsharded collections this contains a single field, _id, with the\n   * value of the _id of the document updated.  For sharded collections,\n   * this will contain all the components of the shard key in order,\n   * followed by the _id if the _id isn’t part of the shard key.\n   */\n  documentKey?: InferIdType<TSchema>;\n\n  /**\n   * Only present for ops of type ‘update’.\n   *\n   * Contains a description of updated and removed fields in this\n   * operation.\n   */\n  updateDescription?: UpdateDescription<TSchema>;\n\n  /**\n   * Always present for operations of type ‘insert’ and ‘replace’. Also\n   * present for operations of type ‘update’ if the user has specified ‘updateLookup’\n   * in the ‘fullDocument’ arguments to the ‘$changeStream’ stage.\n   *\n   * For operations of type ‘insert’ and ‘replace’, this key will contain the\n   * document being inserted, or the new version of the document that is replacing\n   * the existing document, respectively.\n   *\n   * For operations of type ‘update’, this key will contain a copy of the full\n   * version of the document from some point after the update occurred. If the\n   * document was deleted since the updated happened, it will be null.\n   */\n  fullDocument?: TSchema;\n}\n\n/** @public */\nexport interface UpdateDescription<TSchema extends Document = Document> {\n  /**\n   * A document containing key:value pairs of names of the fields that were\n   * changed, and the new value for those fields.\n   */\n  updatedFields: Partial<TSchema>;\n\n  /**\n   * An array of field names that were removed from the document.\n   */\n  removedFields: string[];\n}\n\n/** @public */\nexport type ChangeStreamEvents = {\n  resumeTokenChanged(token: ResumeToken): void;\n  init(response: Document): void;\n  more(response?: Document | undefined): void;\n  response(): void;\n  end(): void;\n  error(error: Error): void;\n  change(change: ChangeStreamDocument): void;\n} & AbstractCursorEvents;\n\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @public\n */\nexport class ChangeStream<\n  TSchema extends Document = Document\n> extends TypedEventEmitter<ChangeStreamEvents> {\n  pipeline: Document[];\n  options: ChangeStreamOptions;\n  parent: MongoClient | Db | Collection;\n  namespace: MongoDBNamespace;\n  type: symbol;\n  /** @internal */\n  cursor?: ChangeStreamCursor<TSchema>;\n  streamOptions?: CursorStreamOptions;\n  /** @internal */\n  [kResumeQueue]: Denque<Callback<ChangeStreamCursor<TSchema>>>;\n  /** @internal */\n  [kCursorStream]?: Readable;\n  /** @internal */\n  [kClosed]: boolean;\n  /** @internal */\n  [kMode]: false | 'iterator' | 'emitter';\n\n  /** @event */\n  static readonly RESPONSE = 'response' as const;\n  /** @event */\n  static readonly MORE = 'more' as const;\n  /** @event */\n  static readonly INIT = 'init' as const;\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n  /**\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\n   * then be passed as soon as it is available.\n   * @event\n   */\n  static readonly CHANGE = 'change' as const;\n  /** @event */\n  static readonly END = 'end' as const;\n  /** @event */\n  static readonly ERROR = 'error' as const;\n  /**\n   * Emitted each time the change stream stores a new resume token.\n   * @event\n   */\n  static readonly RESUME_TOKEN_CHANGED = 'resumeTokenChanged' as const;\n\n  /**\n   * @internal\n   *\n   * @param parent - The parent object that created this change stream\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n   */\n  constructor(\n    parent: OperationParent,\n    pipeline: Document[] = [],\n    options: ChangeStreamOptions = {}\n  ) {\n    super();\n\n    this.pipeline = pipeline;\n    this.options = options;\n\n    if (parent instanceof Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n    } else if (parent instanceof Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n    } else if (parent instanceof MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n    } else {\n      throw new MongoChangeStreamError(\n        'Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient'\n      );\n    }\n\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n    if (!this.options.readPreference && parent.readPreference) {\n      this.options.readPreference = parent.readPreference;\n    }\n\n    this[kResumeQueue] = new Denque();\n\n    // Create contained Change Stream cursor\n    this.cursor = createChangeStreamCursor(this, options);\n\n    this[kClosed] = false;\n    this[kMode] = false;\n\n    // Listen for any `change` listeners being added to ChangeStream\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        streamEvents(this, this.cursor);\n      }\n    });\n\n    this.on('removeListener', eventName => {\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        this[kCursorStream]?.removeAllListeners('data');\n      }\n    });\n  }\n\n  /** @internal */\n  get cursorStream(): Readable | undefined {\n    return this[kCursorStream];\n  }\n\n  /** The cached resume token that is used to resume after the most recently returned change. */\n  get resumeToken(): ResumeToken {\n    return this.cursor?.resumeToken;\n  }\n\n  /** Check if there is any document still available in the Change Stream */\n  hasNext(callback?: Callback): Promise<void> | void {\n    setIsIterator(this);\n    return maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        cursor.hasNext(cb);\n      });\n    });\n  }\n\n  /** Get the next available document from the Change Stream. */\n  next(): Promise<ChangeStreamDocument<TSchema>>;\n  next(callback: Callback<ChangeStreamDocument<TSchema>>): void;\n  next(\n    callback?: Callback<ChangeStreamDocument<TSchema>>\n  ): Promise<ChangeStreamDocument<TSchema>> | void {\n    setIsIterator(this);\n    return maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        cursor.next((error, change) => {\n          if (error) {\n            this[kResumeQueue].push(() => this.next(cb));\n            processError(this, error, cb);\n            return;\n          }\n          processNewChange<TSchema>(this, change, cb);\n        });\n      });\n    });\n  }\n\n  /** Is the cursor closed */\n  get closed(): boolean {\n    return this[kClosed] || (this.cursor?.closed ?? false);\n  }\n\n  /** Close the Change Stream */\n  close(callback?: Callback): Promise<void> | void {\n    this[kClosed] = true;\n\n    return maybePromise(callback, cb => {\n      if (!this.cursor) {\n        return cb();\n      }\n\n      const cursor = this.cursor;\n      return cursor.close(err => {\n        endStream(this);\n        this.cursor = undefined;\n        return cb(err);\n      });\n    });\n  }\n\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @throws MongoDriverError if this.cursor is undefined\n   */\n  stream(options?: CursorStreamOptions): Readable {\n    this.streamOptions = options;\n    if (!this.cursor) throw new MongoChangeStreamError(NO_CURSOR_ERROR);\n    return this.cursor.stream(options);\n  }\n\n  /**\n   * Try to get the next available document from the Change Stream's cursor or `null` if an empty batch is returned\n   */\n  tryNext(): Promise<Document | null>;\n  tryNext(callback: Callback<Document | null>): void;\n  tryNext(callback?: Callback<Document | null>): Promise<Document | null> | void {\n    setIsIterator(this);\n    return maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        return cursor.tryNext(cb);\n      });\n    });\n  }\n}\n\n/** @internal */\nexport interface ChangeStreamCursorOptions extends AbstractCursorOptions {\n  startAtOperationTime?: OperationTime;\n  resumeAfter?: ResumeToken;\n  startAfter?: boolean;\n}\n\n/** @internal */\nexport class ChangeStreamCursor<TSchema extends Document = Document> extends AbstractCursor<\n  ChangeStreamDocument<TSchema>,\n  ChangeStreamEvents\n> {\n  _resumeToken: ResumeToken;\n  startAtOperationTime?: OperationTime;\n  hasReceived?: boolean;\n  resumeAfter: ResumeToken;\n  startAfter: ResumeToken;\n  options: ChangeStreamCursorOptions;\n\n  postBatchResumeToken?: ResumeToken;\n  pipeline: Document[];\n\n  constructor(\n    topology: Topology,\n    namespace: MongoDBNamespace,\n    pipeline: Document[] = [],\n    options: ChangeStreamCursorOptions = {}\n  ) {\n    super(topology, namespace, options);\n\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token: ResumeToken) {\n    this._resumeToken = token;\n    this.emit(ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n\n  get resumeToken(): ResumeToken {\n    return this._resumeToken;\n  }\n\n  get resumeOptions(): ResumeOptions {\n    const result = {} as ResumeOptions;\n    for (const optionName of CURSOR_OPTIONS) {\n      if (Reflect.has(this.options, optionName)) {\n        Reflect.set(result, optionName, Reflect.get(this.options, optionName));\n      }\n    }\n\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key =>\n        Reflect.deleteProperty(result, key)\n      );\n\n      if (this.resumeToken) {\n        const resumeKey =\n          this.options.startAfter && !this.hasReceived ? 'startAfter' : 'resumeAfter';\n        Reflect.set(result, resumeKey, this.resumeToken);\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n\n    return result;\n  }\n\n  cacheResumeToken(resumeToken: ResumeToken): void {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n\n  _processBatch(batchName: string, response?: Document): void {\n    const cursor = response?.cursor || {};\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = cursor.postBatchResumeToken;\n\n      if (cursor[batchName].length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n\n  clone(): AbstractCursor<ChangeStreamDocument<TSchema>> {\n    return new ChangeStreamCursor(this.topology, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n\n  _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void {\n    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n\n    executeOperation(this.topology, aggregateOperation, (err, response) => {\n      if (err || response == null) {\n        return callback(err);\n      }\n\n      const server = aggregateOperation.server;\n      if (\n        this.startAtOperationTime == null &&\n        this.resumeAfter == null &&\n        this.startAfter == null &&\n        maxWireVersion(server) >= 7\n      ) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      this._processBatch('firstBatch', response);\n\n      this.emit(ChangeStream.INIT, response);\n      this.emit(ChangeStream.RESPONSE);\n\n      // TODO: NODE-2882\n      callback(undefined, { server, session, response });\n    });\n  }\n\n  _getMore(batchSize: number, callback: Callback): void {\n    super._getMore(batchSize, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this._processBatch('nextBatch', response);\n\n      this.emit(ChangeStream.MORE, response);\n      this.emit(ChangeStream.RESPONSE);\n      callback(err, response);\n    });\n  }\n}\n\nconst CHANGE_STREAM_EVENTS = [\n  ChangeStream.RESUME_TOKEN_CHANGED,\n  ChangeStream.END,\n  ChangeStream.CLOSE\n];\n\nfunction setIsEmitter<TSchema>(changeStream: ChangeStream<TSchema>): void {\n  if (changeStream[kMode] === 'iterator') {\n    // TODO(NODE-3485): Replace with MongoChangeStreamModeError\n    throw new MongoAPIError(\n      'ChangeStream cannot be used as an EventEmitter after being used as an iterator'\n    );\n  }\n  changeStream[kMode] = 'emitter';\n}\n\nfunction setIsIterator<TSchema>(changeStream: ChangeStream<TSchema>): void {\n  if (changeStream[kMode] === 'emitter') {\n    // TODO(NODE-3485): Replace with MongoChangeStreamModeError\n    throw new MongoAPIError(\n      'ChangeStream cannot be used as an iterator after being used as an EventEmitter'\n    );\n  }\n  changeStream[kMode] = 'iterator';\n}\n/**\n * Create a new change stream cursor based on self's configuration\n * @internal\n */\nfunction createChangeStreamCursor<TSchema>(\n  changeStream: ChangeStream<TSchema>,\n  options: ChangeStreamOptions\n): ChangeStreamCursor<TSchema> {\n  const changeStreamStageOptions: Document = { fullDocument: options.fullDocument || 'default' };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n  if (changeStream.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n\n  const pipeline = [{ $changeStream: changeStreamStageOptions } as Document].concat(\n    changeStream.pipeline\n  );\n\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor<TSchema>(\n    getTopology(changeStream.parent),\n    changeStream.namespace,\n    pipeline,\n    cursorOptions\n  );\n\n  for (const event of CHANGE_STREAM_EVENTS) {\n    changeStreamCursor.on(event, e => changeStream.emit(event, e));\n  }\n\n  if (changeStream.listenerCount(ChangeStream.CHANGE) > 0) {\n    streamEvents(changeStream, changeStreamCursor);\n  }\n\n  return changeStreamCursor;\n}\n\nfunction applyKnownOptions(target: Document, source: Document, optionNames: string[]) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n\n  return target;\n}\n\ninterface TopologyWaitOptions {\n  start?: number;\n  timeout?: number;\n  readPreference?: ReadPreference;\n}\n// This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\nconst SELECTION_TIMEOUT = 30000;\nfunction waitForTopologyConnected(\n  topology: Topology,\n  options: TopologyWaitOptions,\n  callback: Callback\n) {\n  setTimeout(() => {\n    if (options && options.start == null) {\n      options.start = now();\n    }\n\n    const start = options.start || now();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    if (topology.isConnected()) {\n      return callback();\n    }\n\n    if (calculateDurationInMs(start) > timeout) {\n      // TODO(NODE-3497): Replace with MongoNetworkTimeoutError\n      return callback(new MongoRuntimeError('Timed out waiting for connection'));\n    }\n\n    waitForTopologyConnected(topology, options, callback);\n  }, 500); // this is an arbitrary wait time to allow SDAM to transition\n}\n\nfunction closeWithError<T>(\n  changeStream: ChangeStream<T>,\n  error: AnyError,\n  callback?: Callback\n): void {\n  if (!callback) {\n    changeStream.emit(ChangeStream.ERROR, error);\n  }\n\n  changeStream.close(() => callback && callback(error));\n}\n\nfunction streamEvents<TSchema>(\n  changeStream: ChangeStream<TSchema>,\n  cursor: ChangeStreamCursor<TSchema>\n): void {\n  setIsEmitter(changeStream);\n  const stream = changeStream[kCursorStream] || cursor.stream();\n  changeStream[kCursorStream] = stream;\n  stream.on('data', change => processNewChange(changeStream, change));\n  stream.on('error', error => processError(changeStream, error));\n}\n\nfunction endStream<TSchema>(changeStream: ChangeStream<TSchema>): void {\n  const cursorStream = changeStream[kCursorStream];\n  if (cursorStream) {\n    ['data', 'close', 'end', 'error'].forEach(event => cursorStream.removeAllListeners(event));\n    cursorStream.destroy();\n  }\n\n  changeStream[kCursorStream] = undefined;\n}\n\nfunction processNewChange<TSchema>(\n  changeStream: ChangeStream<TSchema>,\n  change: Nullable<ChangeStreamDocument<TSchema>>,\n  callback?: Callback<ChangeStreamDocument<TSchema>>\n) {\n  if (changeStream[kClosed]) {\n    // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n    if (callback) callback(new MongoAPIError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n\n  // a null change means the cursor has been notified, implicitly closing the change stream\n  if (change == null) {\n    // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n    return closeWithError(changeStream, new MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR), callback);\n  }\n\n  if (change && !change._id) {\n    return closeWithError(\n      changeStream,\n      new MongoChangeStreamError(NO_RESUME_TOKEN_ERROR),\n      callback\n    );\n  }\n\n  // cache the resume token\n  changeStream.cursor?.cacheResumeToken(change._id);\n\n  // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n  changeStream.options.startAtOperationTime = undefined;\n\n  // Return the change\n  if (!callback) return changeStream.emit(ChangeStream.CHANGE, change);\n  return callback(undefined, change);\n}\n\nfunction processError<TSchema>(\n  changeStream: ChangeStream<TSchema>,\n  error: AnyError,\n  callback?: Callback\n) {\n  const cursor = changeStream.cursor;\n\n  // If the change stream has been closed explicitly, do not process error.\n  if (changeStream[kClosed]) {\n    // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n    if (callback) callback(new MongoAPIError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n\n  // if the resume succeeds, continue with the new cursor\n  function resumeWithCursor(newCursor: ChangeStreamCursor<TSchema>) {\n    changeStream.cursor = newCursor;\n    processResumeQueue(changeStream);\n  }\n\n  // otherwise, raise an error and close the change stream\n  function unresumableError(err: AnyError) {\n    if (!callback) {\n      changeStream.emit(ChangeStream.ERROR, err);\n    }\n\n    changeStream.close(() => processResumeQueue(changeStream, err));\n  }\n\n  if (cursor && isResumableError(error as MongoError, maxWireVersion(cursor.server))) {\n    changeStream.cursor = undefined;\n\n    // stop listening to all events from old cursor\n    endStream(changeStream);\n\n    // close internal cursor, ignore errors\n    cursor.close();\n\n    const topology = getTopology(changeStream.parent);\n    waitForTopologyConnected(topology, { readPreference: cursor.readPreference }, err => {\n      // if the topology can't reconnect, close the stream\n      if (err) return unresumableError(err);\n\n      // create a new cursor, preserving the old cursor's options\n      const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n\n      // attempt to continue in emitter mode\n      if (!callback) return resumeWithCursor(newCursor);\n\n      // attempt to continue in iterator mode\n      newCursor.hasNext(err => {\n        // if there's an error immediately after resuming, close the stream\n        if (err) return unresumableError(err);\n        resumeWithCursor(newCursor);\n      });\n    });\n    return;\n  }\n\n  // if initial error wasn't resumable, raise an error and close the change stream\n  return closeWithError(changeStream, error, callback);\n}\n\n/**\n * Safely provides a cursor across resume attempts\n *\n * @param changeStream - the parent ChangeStream\n */\nfunction getCursor<T>(changeStream: ChangeStream<T>, callback: Callback<ChangeStreamCursor<T>>) {\n  if (changeStream[kClosed]) {\n    // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n    callback(new MongoAPIError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n\n  // if a cursor exists and it is open, return it\n  if (changeStream.cursor) {\n    callback(undefined, changeStream.cursor);\n    return;\n  }\n\n  // no cursor, queue callback until topology reconnects\n  changeStream[kResumeQueue].push(callback);\n}\n\n/**\n * Drain the resume queue when a new has become available\n *\n * @param changeStream - the parent ChangeStream\n * @param err - error getting a new cursor\n */\nfunction processResumeQueue<TSchema>(changeStream: ChangeStream<TSchema>, err?: Error) {\n  while (changeStream[kResumeQueue].length) {\n    const request = changeStream[kResumeQueue].pop();\n    if (!request) break; // Should never occur but TS can't use the length check in the while condition\n\n    if (!err) {\n      if (changeStream[kClosed]) {\n        // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n        request(new MongoAPIError(CHANGESTREAM_CLOSED_ERROR));\n        return;\n      }\n      if (!changeStream.cursor) {\n        request(new MongoChangeStreamError(NO_CURSOR_ERROR));\n        return;\n      }\n    }\n    request(err, changeStream.cursor);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}