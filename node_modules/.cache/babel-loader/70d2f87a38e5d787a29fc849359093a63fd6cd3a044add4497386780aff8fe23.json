{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ListCollectionsCursor = exports.ListCollectionsOperation = void 0;\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\nconst utils_1 = require(\"../utils\");\nconst CONSTANTS = require(\"../constants\");\nconst abstract_cursor_1 = require(\"../cursor/abstract_cursor\");\nconst execute_operation_1 = require(\"./execute_operation\");\nconst LIST_COLLECTIONS_WIRE_VERSION = 3;\n/** @internal */\nclass ListCollectionsOperation extends command_1.CommandOperation {\n  constructor(db, filter, options) {\n    super(db, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.db = db;\n    this.filter = filter;\n    this.nameOnly = !!this.options.nameOnly;\n    if (typeof this.options.batchSize === 'number') {\n      this.batchSize = this.options.batchSize;\n    }\n  }\n  execute(server, session, callback) {\n    if (utils_1.maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {\n      let filter = this.filter;\n      const databaseName = this.db.s.namespace.db;\n      // If we have legacy mode and have not provided a full db name filter it\n      if (typeof filter.name === 'string' && !new RegExp(`^${databaseName}\\\\.`).test(filter.name)) {\n        filter = Object.assign({}, filter);\n        filter.name = this.db.s.namespace.withCollection(filter.name).toString();\n      }\n      // No filter, filter by current database\n      if (filter == null) {\n        filter = {\n          name: `/${databaseName}/`\n        };\n      }\n      // Rewrite the filter to use $and to filter out indexes\n      if (filter.name) {\n        filter = {\n          $and: [{\n            name: filter.name\n          }, {\n            name: /^((?!\\$).)*$/\n          }]\n        };\n      } else {\n        filter = {\n          name: /^((?!\\$).)*$/\n        };\n      }\n      const documentTransform = doc => {\n        const matching = `${databaseName}.`;\n        const index = doc.name.indexOf(matching);\n        // Remove database name if available\n        if (doc.name && index === 0) {\n          doc.name = doc.name.substr(index + matching.length);\n        }\n        return doc;\n      };\n      server.query(new utils_1.MongoDBNamespace(databaseName, CONSTANTS.SYSTEM_NAMESPACE_COLLECTION), {\n        query: filter\n      }, {\n        batchSize: this.batchSize || 1000,\n        readPreference: this.readPreference\n      }, (err, result) => {\n        if (result && result.documents && Array.isArray(result.documents)) {\n          result.documents = result.documents.map(documentTransform);\n        }\n        callback(err, result);\n      });\n      return;\n    }\n    const command = {\n      listCollections: 1,\n      filter: this.filter,\n      cursor: this.batchSize ? {\n        batchSize: this.batchSize\n      } : {},\n      nameOnly: this.nameOnly\n    };\n    return super.executeCommand(server, session, command, callback);\n  }\n}\nexports.ListCollectionsOperation = ListCollectionsOperation;\n/** @public */\nclass ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(db, filter, options) {\n    super(utils_1.getTopology(db), db.s.namespace, options);\n    this.parent = db;\n    this.filter = filter;\n    this.options = options;\n  }\n  clone() {\n    return new ListCollectionsCursor(this.parent, this.filter, {\n      ...this.options,\n      ...this.cursorOptions\n    });\n  }\n  /** @internal */\n  _initialize(session, callback) {\n    const operation = new ListCollectionsOperation(this.parent, this.filter, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    execute_operation_1.executeOperation(utils_1.getTopology(this.parent), operation, (err, response) => {\n      if (err || response == null) return callback(err);\n      // TODO: NODE-2882\n      callback(undefined, {\n        server: operation.server,\n        session,\n        response\n      });\n    });\n  }\n}\nexports.ListCollectionsCursor = ListCollectionsCursor;\noperation_1.defineAspects(ListCollectionsOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);","map":{"version":3,"mappings":"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","names":["LIST_COLLECTIONS_WIRE_VERSION","ListCollectionsOperation","command_1","constructor","db","filter","options","nameOnly","batchSize","execute","server","session","callback","utils_1","databaseName","s","namespace","name","RegExp","test","Object","assign","withCollection","toString","$and","documentTransform","doc","matching","index","indexOf","substr","length","query","CONSTANTS","SYSTEM_NAMESPACE_COLLECTION","readPreference","err","result","documents","Array","isArray","map","command","listCollections","cursor","executeCommand","exports","ListCollectionsCursor","abstract_cursor_1","parent","clone","cursorOptions","_initialize","operation","execute_operation_1","response","undefined","operation_1","READ_OPERATION","RETRYABLE","CURSOR_CREATING"],"sources":["C:\\Users\\danin\\node_modules\\mongodb\\src\\operations\\list_collections.ts"],"sourcesContent":["import { CommandOperation, CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\nimport { maxWireVersion, Callback, getTopology, MongoDBNamespace } from '../utils';\nimport * as CONSTANTS from '../constants';\nimport type { Binary, Document } from '../bson';\nimport type { Server } from '../sdam/server';\nimport type { Db } from '../db';\nimport { AbstractCursor } from '../cursor/abstract_cursor';\nimport type { ClientSession } from '../sessions';\nimport { executeOperation, ExecutionResult } from './execute_operation';\n\nconst LIST_COLLECTIONS_WIRE_VERSION = 3;\n\n/** @public */\nexport interface ListCollectionsOptions extends CommandOperationOptions {\n  /** Since 4.0: If true, will only return the collection name in the response, and will omit additional info */\n  nameOnly?: boolean;\n  /** The batchSize for the returned command cursor or if pre 2.8 the systems batch collection */\n  batchSize?: number;\n}\n\n/** @internal */\nexport class ListCollectionsOperation extends CommandOperation<string[]> {\n  options: ListCollectionsOptions;\n  db: Db;\n  filter: Document;\n  nameOnly: boolean;\n  batchSize?: number;\n\n  constructor(db: Db, filter: Document, options?: ListCollectionsOptions) {\n    super(db, options);\n\n    this.options = options ?? {};\n    this.db = db;\n    this.filter = filter;\n    this.nameOnly = !!this.options.nameOnly;\n\n    if (typeof this.options.batchSize === 'number') {\n      this.batchSize = this.options.batchSize;\n    }\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<string[]>): void {\n    if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {\n      let filter = this.filter;\n      const databaseName = this.db.s.namespace.db;\n\n      // If we have legacy mode and have not provided a full db name filter it\n      if (typeof filter.name === 'string' && !new RegExp(`^${databaseName}\\\\.`).test(filter.name)) {\n        filter = Object.assign({}, filter);\n        filter.name = this.db.s.namespace.withCollection(filter.name).toString();\n      }\n\n      // No filter, filter by current database\n      if (filter == null) {\n        filter = { name: `/${databaseName}/` };\n      }\n\n      // Rewrite the filter to use $and to filter out indexes\n      if (filter.name) {\n        filter = { $and: [{ name: filter.name }, { name: /^((?!\\$).)*$/ }] };\n      } else {\n        filter = { name: /^((?!\\$).)*$/ };\n      }\n\n      const documentTransform = (doc: Document) => {\n        const matching = `${databaseName}.`;\n        const index = doc.name.indexOf(matching);\n        // Remove database name if available\n        if (doc.name && index === 0) {\n          doc.name = doc.name.substr(index + matching.length);\n        }\n\n        return doc;\n      };\n\n      server.query(\n        new MongoDBNamespace(databaseName, CONSTANTS.SYSTEM_NAMESPACE_COLLECTION),\n        { query: filter },\n        { batchSize: this.batchSize || 1000, readPreference: this.readPreference },\n        (err, result) => {\n          if (result && result.documents && Array.isArray(result.documents)) {\n            result.documents = result.documents.map(documentTransform);\n          }\n\n          callback(err, result);\n        }\n      );\n\n      return;\n    }\n\n    const command = {\n      listCollections: 1,\n      filter: this.filter,\n      cursor: this.batchSize ? { batchSize: this.batchSize } : {},\n      nameOnly: this.nameOnly\n    };\n\n    return super.executeCommand(server, session, command, callback);\n  }\n}\n\n/** @public */\nexport interface CollectionInfo extends Document {\n  name: string;\n  type?: string;\n  options?: Document;\n  info?: {\n    readOnly?: false;\n    uuid?: Binary;\n  };\n  idIndex?: Document;\n}\n\n/** @public */\nexport class ListCollectionsCursor<\n  T extends Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo =\n    | Pick<CollectionInfo, 'name' | 'type'>\n    | CollectionInfo\n> extends AbstractCursor<T> {\n  parent: Db;\n  filter: Document;\n  options?: ListCollectionsOptions;\n\n  constructor(db: Db, filter: Document, options?: ListCollectionsOptions) {\n    super(getTopology(db), db.s.namespace, options);\n    this.parent = db;\n    this.filter = filter;\n    this.options = options;\n  }\n\n  clone(): ListCollectionsCursor<T> {\n    return new ListCollectionsCursor(this.parent, this.filter, {\n      ...this.options,\n      ...this.cursorOptions\n    });\n  }\n\n  /** @internal */\n  _initialize(session: ClientSession | undefined, callback: Callback<ExecutionResult>): void {\n    const operation = new ListCollectionsOperation(this.parent, this.filter, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n\n    executeOperation(getTopology(this.parent), operation, (err, response) => {\n      if (err || response == null) return callback(err);\n\n      // TODO: NODE-2882\n      callback(undefined, { server: operation.server, session, response });\n    });\n  }\n}\n\ndefineAspects(ListCollectionsOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.CURSOR_CREATING\n]);\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}