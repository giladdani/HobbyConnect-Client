{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoClient = exports.ServerApiVersion = void 0;\nconst db_1 = require(\"./db\");\nconst change_stream_1 = require(\"./change_stream\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nconst connect_1 = require(\"./operations/connect\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst bson_1 = require(\"./bson\");\nconst connection_string_1 = require(\"./connection_string\");\nconst mongo_types_1 = require(\"./mongo_types\");\n/** @public */\nexports.ServerApiVersion = Object.freeze({\n  v1: '1'\n});\n/** @internal */\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedent over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n  constructor(url, options) {\n    super();\n    this[kOptions] = connection_string_1.parseOptions(url, this, options);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const client = this;\n    // The internal state\n    this.s = {\n      url,\n      sessions: new Set(),\n      bsonOptions: bson_1.resolveBSONOptions(this[kOptions]),\n      namespace: utils_1.ns('admin'),\n      get options() {\n        return client[kOptions];\n      },\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n      get logger() {\n        return client[kOptions].logger;\n      }\n    };\n  }\n  get options() {\n    return Object.freeze({\n      ...this[kOptions]\n    });\n  }\n  get serverApi() {\n    return this[kOptions].serverApi && Object.freeze({\n      ...this[kOptions].serverApi\n    });\n  }\n  /**\n   * Intended for APM use only\n   * @internal\n   */\n  get monitorCommands() {\n    return this[kOptions].monitorCommands;\n  }\n  set monitorCommands(value) {\n    this[kOptions].monitorCommands = value;\n  }\n  get autoEncrypter() {\n    return this[kOptions].autoEncrypter;\n  }\n  get readConcern() {\n    return this.s.readConcern;\n  }\n  get writeConcern() {\n    return this.s.writeConcern;\n  }\n  get readPreference() {\n    return this.s.readPreference;\n  }\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  get logger() {\n    return this.s.logger;\n  }\n  connect(callback) {\n    if (callback && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n    }\n    return utils_1.maybePromise(callback, cb => {\n      connect_1.connect(this, this[kOptions], err => {\n        if (err) return cb(err);\n        cb(undefined, this);\n      });\n    });\n  }\n  close(forceOrCallback, callback) {\n    if (typeof forceOrCallback === 'function') {\n      callback = forceOrCallback;\n    }\n    const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n    return utils_1.maybePromise(callback, callback => {\n      if (this.topology == null) {\n        return callback();\n      }\n      // clear out references to old topology\n      const topology = this.topology;\n      this.topology = undefined;\n      topology.close({\n        force\n      }, error => {\n        if (error) return callback(error);\n        const {\n          encrypter\n        } = this[kOptions];\n        if (encrypter) {\n          return encrypter.close(this, force, error => {\n            callback(error);\n          });\n        }\n        callback();\n      });\n    });\n  }\n  /**\n   * Create a new Db instance sharing the current socket connections.\n   *\n   * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n   * @param options - Optional settings for Db construction\n   */\n  db(dbName, options) {\n    options = options !== null && options !== void 0 ? options : {};\n    // Default to db from connection string if not provided\n    if (!dbName) {\n      dbName = this.options.dbName;\n    }\n    // Copy the options and add out internal override of the not shared flag\n    const finalOptions = Object.assign({}, this[kOptions], options);\n    // Return the db object\n    const db = new db_1.Db(this, dbName, finalOptions);\n    // Return the database\n    return db;\n  }\n  static connect(url, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    try {\n      // Create client\n      const mongoClient = new MongoClient(url, options);\n      // Execute the connect method\n      if (callback) {\n        return mongoClient.connect(callback);\n      } else {\n        return mongoClient.connect();\n      }\n    } catch (error) {\n      if (callback) return callback(error);else return promise_provider_1.PromiseProvider.get().reject(error);\n    }\n  }\n  startSession(options) {\n    options = Object.assign({\n      explicit: true\n    }, options);\n    if (!this.topology) {\n      throw new error_1.MongoNotConnectedError('MongoClient must be connected to start a session');\n    }\n    return this.topology.startSession(options, this.s.options);\n  }\n  withSession(optionsOrOperation, callback) {\n    let options = optionsOrOperation;\n    if (typeof optionsOrOperation === 'function') {\n      callback = optionsOrOperation;\n      options = {\n        owner: Symbol()\n      };\n    }\n    if (callback == null) {\n      throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n    }\n    const session = this.startSession(options);\n    const Promise = promise_provider_1.PromiseProvider.get();\n    let cleanupHandler = (err, result, opts) => {\n      // prevent multiple calls to cleanupHandler\n      cleanupHandler = () => {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('cleanupHandler was called too many times');\n      };\n      opts = Object.assign({\n        throw: true\n      }, opts);\n      session.endSession();\n      if (err) {\n        if (opts.throw) throw err;\n        return Promise.reject(err);\n      }\n    };\n    try {\n      const result = callback(session);\n      return Promise.resolve(result).then(result => cleanupHandler(undefined, result, undefined), err => cleanupHandler(err, null, {\n        throw: true\n      }));\n    } catch (err) {\n      return cleanupHandler(err, null, {\n        throw: false\n      });\n    }\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this cluster. Will ignore all\n   * changes to system collections, as well as the local, admin, and config databases.\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n  watch() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n    return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n  }\n  /** Return the mongo client logger */\n  getLogger() {\n    return this.s.logger;\n  }\n}\nexports.MongoClient = MongoClient;","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AAEA;AAOA;AASA;AACA;AAGA;AAOA;AAQA;AAEA;AACaA,wBAAgB,GAAGC,MAAM,CAACC,MAAM,CAAC;EAC5CC,EAAE,EAAE;CACI,CAAC;AAiOX;AACA,MAAMC,QAAQ,GAAGC,MAAM,CAAC,SAAS,CAAC;AAElC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCA,MAAaC,WAAY,SAAQC,+BAAoC;EAYnEC,YAAYC,GAAW,EAAEC,OAA4B;IACnD,KAAK,EAAE;IAEP,IAAI,CAACN,QAAQ,CAAC,GAAGO,gCAAY,CAACF,GAAG,EAAE,IAAI,EAAEC,OAAO,CAAC;IAEjD;IACA,MAAME,MAAM,GAAG,IAAI;IAEnB;IACA,IAAI,CAACC,CAAC,GAAG;MACPJ,GAAG;MACHK,QAAQ,EAAE,IAAIC,GAAG,EAAE;MACnBC,WAAW,EAAEC,yBAAkB,CAAC,IAAI,CAACb,QAAQ,CAAC,CAAC;MAC/Cc,SAAS,EAAEC,UAAE,CAAC,OAAO,CAAC;MAEtB,IAAIT,OAAO;QACT,OAAOE,MAAM,CAACR,QAAQ,CAAC;MACzB,CAAC;MACD,IAAIgB,WAAW;QACb,OAAOR,MAAM,CAACR,QAAQ,CAAC,CAACgB,WAAW;MACrC,CAAC;MACD,IAAIC,YAAY;QACd,OAAOT,MAAM,CAACR,QAAQ,CAAC,CAACiB,YAAY;MACtC,CAAC;MACD,IAAIC,cAAc;QAChB,OAAOV,MAAM,CAACR,QAAQ,CAAC,CAACkB,cAAc;MACxC,CAAC;MACD,IAAIC,MAAM;QACR,OAAOX,MAAM,CAACR,QAAQ,CAAC,CAACmB,MAAM;MAChC;KACD;EACH;EAEA,IAAIb,OAAO;IACT,OAAOT,MAAM,CAACC,MAAM,CAAC;MAAE,GAAG,IAAI,CAACE,QAAQ;IAAC,CAAE,CAAC;EAC7C;EAEA,IAAIoB,SAAS;IACX,OAAO,IAAI,CAACpB,QAAQ,CAAC,CAACoB,SAAS,IAAIvB,MAAM,CAACC,MAAM,CAAC;MAAE,GAAG,IAAI,CAACE,QAAQ,CAAC,CAACoB;IAAS,CAAE,CAAC;EACnF;EACA;;;;EAIA,IAAIC,eAAe;IACjB,OAAO,IAAI,CAACrB,QAAQ,CAAC,CAACqB,eAAe;EACvC;EACA,IAAIA,eAAe,CAACC,KAAc;IAChC,IAAI,CAACtB,QAAQ,CAAC,CAACqB,eAAe,GAAGC,KAAK;EACxC;EAEA,IAAIC,aAAa;IACf,OAAO,IAAI,CAACvB,QAAQ,CAAC,CAACuB,aAAa;EACrC;EAEA,IAAIP,WAAW;IACb,OAAO,IAAI,CAACP,CAAC,CAACO,WAAW;EAC3B;EAEA,IAAIC,YAAY;IACd,OAAO,IAAI,CAACR,CAAC,CAACQ,YAAY;EAC5B;EAEA,IAAIC,cAAc;IAChB,OAAO,IAAI,CAACT,CAAC,CAACS,cAAc;EAC9B;EAEA,IAAIN,WAAW;IACb,OAAO,IAAI,CAACH,CAAC,CAACG,WAAW;EAC3B;EAEA,IAAIO,MAAM;IACR,OAAO,IAAI,CAACV,CAAC,CAACU,MAAM;EACtB;EASAK,OAAO,CAACC,QAAgC;IACtC,IAAIA,QAAQ,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MAC9C,MAAM,IAAIC,iCAAyB,CAAC,0CAA0C,CAAC;;IAGjF,OAAOX,oBAAY,CAACU,QAAQ,EAAEE,EAAE,IAAG;MACjCC,iBAAO,CAAC,IAAI,EAAE,IAAI,CAAC5B,QAAQ,CAAC,EAAE6B,GAAG,IAAG;QAClC,IAAIA,GAAG,EAAE,OAAOF,EAAE,CAACE,GAAG,CAAC;QACvBF,EAAE,CAACG,SAAS,EAAE,IAAI,CAAC;MACrB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAYAC,KAAK,CACHC,eAA0C,EAC1CP,QAAyB;IAEzB,IAAI,OAAOO,eAAe,KAAK,UAAU,EAAE;MACzCP,QAAQ,GAAGO,eAAe;;IAG5B,MAAMC,KAAK,GAAG,OAAOD,eAAe,KAAK,SAAS,GAAGA,eAAe,GAAG,KAAK;IAE5E,OAAOjB,oBAAY,CAACU,QAAQ,EAAEA,QAAQ,IAAG;MACvC,IAAI,IAAI,CAACS,QAAQ,IAAI,IAAI,EAAE;QACzB,OAAOT,QAAQ,EAAE;;MAGnB;MACA,MAAMS,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAC9B,IAAI,CAACA,QAAQ,GAAGJ,SAAS;MAEzBI,QAAQ,CAACH,KAAK,CAAC;QAAEE;MAAK,CAAE,EAAEE,KAAK,IAAG;QAChC,IAAIA,KAAK,EAAE,OAAOV,QAAQ,CAACU,KAAK,CAAC;QACjC,MAAM;UAAEC;QAAS,CAAE,GAAG,IAAI,CAACpC,QAAQ,CAAC;QACpC,IAAIoC,SAAS,EAAE;UACb,OAAOA,SAAS,CAACL,KAAK,CAAC,IAAI,EAAEE,KAAK,EAAEE,KAAK,IAAG;YAC1CV,QAAQ,CAACU,KAAK,CAAC;UACjB,CAAC,CAAC;;QAEJV,QAAQ,EAAE;MACZ,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;;;;;;EAMAY,EAAE,CAACC,MAAe,EAAEhC,OAAmB;IACrCA,OAAO,GAAGA,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,EAAE;IAEvB;IACA,IAAI,CAACgC,MAAM,EAAE;MACXA,MAAM,GAAG,IAAI,CAAChC,OAAO,CAACgC,MAAM;;IAG9B;IACA,MAAMC,YAAY,GAAG1C,MAAM,CAAC2C,MAAM,CAAC,EAAE,EAAE,IAAI,CAACxC,QAAQ,CAAC,EAAEM,OAAO,CAAC;IAE/D;IACA,MAAM+B,EAAE,GAAG,IAAII,OAAE,CAAC,IAAI,EAAEH,MAAM,EAAEC,YAAY,CAAC;IAE7C;IACA,OAAOF,EAAE;EACX;EAcA,OAAOb,OAAO,CACZnB,GAAW,EACXC,OAAoD,EACpDmB,QAAgC;IAEhC,IAAI,OAAOnB,OAAO,KAAK,UAAU,EAAGmB,QAAQ,GAAGnB,OAAO,EAAIA,OAAO,GAAG,EAAG;IACvEA,OAAO,GAAGA,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,EAAE;IAEvB,IAAI;MACF;MACA,MAAMoC,WAAW,GAAG,IAAIxC,WAAW,CAACG,GAAG,EAAEC,OAAO,CAAC;MACjD;MACA,IAAImB,QAAQ,EAAE;QACZ,OAAOiB,WAAW,CAAClB,OAAO,CAACC,QAAQ,CAAC;OACrC,MAAM;QACL,OAAOiB,WAAW,CAAClB,OAAO,EAAE;;KAE/B,CAAC,OAAOW,KAAK,EAAE;MACd,IAAIV,QAAQ,EAAE,OAAOA,QAAQ,CAACU,KAAK,CAAC,CAAC,KAChC,OAAOQ,kCAAe,CAACC,GAAG,EAAE,CAACC,MAAM,CAACV,KAAK,CAAC;;EAEnD;EAKAW,YAAY,CAACxC,OAA8B;IACzCA,OAAO,GAAGT,MAAM,CAAC2C,MAAM,CAAC;MAAEO,QAAQ,EAAE;IAAI,CAAE,EAAEzC,OAAO,CAAC;IACpD,IAAI,CAAC,IAAI,CAAC4B,QAAQ,EAAE;MAClB,MAAM,IAAIR,8BAAsB,CAAC,kDAAkD,CAAC;;IAGtF,OAAO,IAAI,CAACQ,QAAQ,CAACY,YAAY,CAACxC,OAAO,EAAE,IAAI,CAACG,CAAC,CAACH,OAAO,CAAC;EAC5D;EAaA0C,WAAW,CACTC,kBAA+D,EAC/DxB,QAA8B;IAE9B,IAAInB,OAAO,GAAyB2C,kBAA0C;IAC9E,IAAI,OAAOA,kBAAkB,KAAK,UAAU,EAAE;MAC5CxB,QAAQ,GAAGwB,kBAAyC;MACpD3C,OAAO,GAAG;QAAE4C,KAAK,EAAEjD,MAAM;MAAE,CAAE;;IAG/B,IAAIwB,QAAQ,IAAI,IAAI,EAAE;MACpB,MAAM,IAAIC,iCAAyB,CAAC,qCAAqC,CAAC;;IAG5E,MAAMyB,OAAO,GAAG,IAAI,CAACL,YAAY,CAACxC,OAAO,CAAC;IAC1C,MAAM8C,OAAO,GAAGT,kCAAe,CAACC,GAAG,EAAE;IAErC,IAAIS,cAAc,GAA4B,CAACxB,GAAG,EAAEyB,MAAM,EAAEC,IAAI,KAAI;MAClE;MACAF,cAAc,GAAG,MAAK;QACpB;QACA,MAAM,IAAI3B,yBAAiB,CAAC,0CAA0C,CAAC;MACzE,CAAC;MAED6B,IAAI,GAAG1D,MAAM,CAAC2C,MAAM,CAAC;QAAEgB,KAAK,EAAE;MAAI,CAAE,EAAED,IAAI,CAAC;MAC3CJ,OAAO,CAACM,UAAU,EAAE;MAEpB,IAAI5B,GAAG,EAAE;QACP,IAAI0B,IAAI,CAACC,KAAK,EAAE,MAAM3B,GAAG;QACzB,OAAOuB,OAAO,CAACP,MAAM,CAAChB,GAAG,CAAC;;IAE9B,CAA4B;IAE5B,IAAI;MACF,MAAMyB,MAAM,GAAG7B,QAAQ,CAAC0B,OAAO,CAAC;MAChC,OAAOC,OAAO,CAACM,OAAO,CAACJ,MAAM,CAAC,CAACK,IAAI,CACjCL,MAAM,IAAID,cAAc,CAACvB,SAAS,EAAEwB,MAAM,EAAExB,SAAS,CAAC,EACtDD,GAAG,IAAIwB,cAAc,CAACxB,GAAG,EAAE,IAAI,EAAE;QAAE2B,KAAK,EAAE;MAAI,CAAE,CAAC,CAClD;KACF,CAAC,OAAO3B,GAAG,EAAE;MACZ,OAAOwB,cAAc,CAACxB,GAAG,EAAE,IAAI,EAAE;QAAE2B,KAAK,EAAE;MAAK,CAAE,CAAkB;;EAEvE;EAEA;;;;;;;;EAQAI,KAAK,GAE8B;IAAA,IADjCC,+EAAuB,EAAE;IAAA,IACzBvD,8EAA+B,EAAE;IAEjC;IACA,IAAI,CAACwD,KAAK,CAACC,OAAO,CAACF,QAAQ,CAAC,EAAE;MAC5BvD,OAAO,GAAGuD,QAAQ;MAClBA,QAAQ,GAAG,EAAE;;IAGf,OAAO,IAAIG,4BAAY,CAAU,IAAI,EAAEH,QAAQ,EAAE9C,sBAAc,CAAC,IAAI,EAAET,OAAO,CAAC,CAAC;EACjF;EAEA;EACA2D,SAAS;IACP,OAAO,IAAI,CAACxD,CAAC,CAACU,MAAM;EACtB;;AA3SFvB","names":["exports","Object","freeze","v1","kOptions","Symbol","MongoClient","mongo_types_1","constructor","url","options","connection_string_1","client","s","sessions","Set","bsonOptions","bson_1","namespace","utils_1","readConcern","writeConcern","readPreference","logger","serverApi","monitorCommands","value","autoEncrypter","connect","callback","error_1","cb","connect_1","err","undefined","close","forceOrCallback","force","topology","error","encrypter","db","dbName","finalOptions","assign","db_1","mongoClient","promise_provider_1","get","reject","startSession","explicit","withSession","optionsOrOperation","owner","session","Promise","cleanupHandler","result","opts","throw","endSession","resolve","then","watch","pipeline","Array","isArray","change_stream_1","getLogger"],"sources":["C:\\Users\\danin\\node_modules\\mongodb\\src\\mongo_client.ts"],"sourcesContent":["import { Db, DbOptions } from './db';\nimport { ChangeStream, ChangeStreamOptions } from './change_stream';\nimport type { ReadPreference, ReadPreferenceMode } from './read_preference';\nimport {\n  AnyError,\n  MongoRuntimeError,\n  MongoInvalidArgumentError,\n  MongoNotConnectedError\n} from './error';\nimport type { W, WriteConcern } from './write_concern';\nimport {\n  maybePromise,\n  MongoDBNamespace,\n  Callback,\n  resolveOptions,\n  ClientMetadata,\n  ns,\n  HostAddress\n} from './utils';\nimport { connect, MONGO_CLIENT_EVENTS } from './operations/connect';\nimport { PromiseProvider } from './promise_provider';\nimport type { Logger, LoggerLevel } from './logger';\nimport type { ReadConcern, ReadConcernLevel, ReadConcernLike } from './read_concern';\nimport { BSONSerializeOptions, Document, resolveBSONOptions } from './bson';\nimport type { AutoEncrypter, AutoEncryptionOptions } from './deps';\nimport type { AuthMechanism } from './cmap/auth/defaultAuthProviders';\nimport type { Topology, TopologyEvents } from './sdam/topology';\nimport type { ClientSession, ClientSessionOptions } from './sessions';\nimport type { TagSet } from './sdam/server_description';\nimport type { AuthMechanismProperties, MongoCredentials } from './cmap/auth/mongo_credentials';\nimport { parseOptions } from './connection_string';\nimport type { CompressorName } from './cmap/wire_protocol/compression';\nimport type { TLSSocketOptions, ConnectionOptions as TLSConnectionOptions } from 'tls';\nimport type { TcpNetConnectOpts } from 'net';\nimport type { SrvPoller } from './sdam/srv_polling';\nimport type { Connection } from './cmap/connection';\nimport type { LEGAL_TLS_SOCKET_OPTIONS, LEGAL_TCP_SOCKET_OPTIONS } from './cmap/connect';\nimport type { Encrypter } from './encrypter';\nimport { TypedEventEmitter } from './mongo_types';\n\n/** @public */\nexport const ServerApiVersion = Object.freeze({\n  v1: '1'\n} as const);\n\n/** @public */\nexport type ServerApiVersion = typeof ServerApiVersion[keyof typeof ServerApiVersion];\n\n/** @public */\nexport interface ServerApi {\n  version: ServerApiVersion;\n  strict?: boolean;\n  deprecationErrors?: boolean;\n}\n\n/** @public */\nexport interface DriverInfo {\n  name?: string;\n  version?: string;\n  platform?: string;\n}\n\n/** @public */\nexport interface Auth {\n  /** The username for auth */\n  username?: string;\n  /** The password for auth */\n  password?: string;\n}\n\n/** @public */\nexport interface PkFactory {\n  createPk(): any; // TODO: when js-bson is typed, function should return some BSON type\n}\n\ntype CleanUpHandlerFunction = (err?: AnyError, result?: any, opts?: any) => Promise<void>;\n\n/** @public */\nexport type SupportedTLSConnectionOptions = Pick<\n  TLSConnectionOptions,\n  Extract<keyof TLSConnectionOptions, typeof LEGAL_TLS_SOCKET_OPTIONS[number]>\n>;\n\n/** @public */\nexport type SupportedTLSSocketOptions = Pick<\n  TLSSocketOptions,\n  Extract<keyof TLSSocketOptions, typeof LEGAL_TLS_SOCKET_OPTIONS[number]>\n>;\n\n/** @public */\nexport type SupportedSocketOptions = Pick<\n  TcpNetConnectOpts,\n  typeof LEGAL_TCP_SOCKET_OPTIONS[number]\n>;\n\n/** @public */\nexport type SupportedNodeConnectionOptions = SupportedTLSConnectionOptions &\n  SupportedTLSSocketOptions &\n  SupportedSocketOptions;\n\n/**\n * Describes all possible URI query options for the mongo client\n * @public\n * @see https://docs.mongodb.com/manual/reference/connection-string\n */\nexport interface MongoClientOptions extends BSONSerializeOptions, SupportedNodeConnectionOptions {\n  /** Specifies the name of the replica set, if the mongod is a member of a replica set. */\n  replicaSet?: string;\n  /** Enables or disables TLS/SSL for the connection. */\n  tls?: boolean;\n  /** A boolean to enable or disables TLS/SSL for the connection. (The ssl option is equivalent to the tls option.) */\n  ssl?: boolean;\n  /** Specifies the location of a local TLS Certificate */\n  tlsCertificateFile?: string;\n  /** Specifies the location of a local .pem file that contains either the client's TLS/SSL certificate and key or only the client's TLS/SSL key when tlsCertificateFile is used to provide the certificate. */\n  tlsCertificateKeyFile?: string;\n  /** Specifies the password to de-crypt the tlsCertificateKeyFile. */\n  tlsCertificateKeyFilePassword?: string;\n  /** Specifies the location of a local .pem file that contains the root certificate chain from the Certificate Authority. This file is used to validate the certificate presented by the mongod/mongos instance. */\n  tlsCAFile?: string;\n  /** Bypasses validation of the certificates presented by the mongod/mongos instance */\n  tlsAllowInvalidCertificates?: boolean;\n  /** Disables hostname validation of the certificate presented by the mongod/mongos instance. */\n  tlsAllowInvalidHostnames?: boolean;\n  /** Disables various certificate validations. */\n  tlsInsecure?: boolean;\n  /** The time in milliseconds to attempt a connection before timing out. */\n  connectTimeoutMS?: number;\n  /** The time in milliseconds to attempt a send or receive on a socket before the attempt times out. */\n  socketTimeoutMS?: number;\n  /** An array or comma-delimited string of compressors to enable network compression for communication between this client and a mongod/mongos instance. */\n  compressors?: CompressorName[] | string;\n  /** An integer that specifies the compression level if using zlib for network compression. */\n  zlibCompressionLevel?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | undefined;\n  /** The maximum number of connections in the connection pool. */\n  maxPoolSize?: number;\n  /** The minimum number of connections in the connection pool. */\n  minPoolSize?: number;\n  /** The maximum number of milliseconds that a connection can remain idle in the pool before being removed and closed. */\n  maxIdleTimeMS?: number;\n  /** The maximum time in milliseconds that a thread can wait for a connection to become available. */\n  waitQueueTimeoutMS?: number;\n  /** Specify a read concern for the collection (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcernLike;\n  /** The level of isolation */\n  readConcernLevel?: ReadConcernLevel;\n  /** Specifies the read preferences for this connection */\n  readPreference?: ReadPreferenceMode | ReadPreference;\n  /** Specifies, in seconds, how stale a secondary can be before the client stops using it for read operations. */\n  maxStalenessSeconds?: number;\n  /** Specifies the tags document as a comma-separated list of colon-separated key-value pairs.  */\n  readPreferenceTags?: TagSet[];\n  /** The auth settings for when connection to server. */\n  auth?: Auth;\n  /** Specify the database name associated with the userâ€™s credentials. */\n  authSource?: string;\n  /** Specify the authentication mechanism that MongoDB will use to authenticate the connection. */\n  authMechanism?: AuthMechanism;\n  /** Specify properties for the specified authMechanism as a comma-separated list of colon-separated key-value pairs. */\n  authMechanismProperties?: AuthMechanismProperties;\n  /** The size (in milliseconds) of the latency window for selecting among multiple suitable MongoDB instances. */\n  localThresholdMS?: number;\n  /** Specifies how long (in milliseconds) to block for server selection before throwing an exception.  */\n  serverSelectionTimeoutMS?: number;\n  /** heartbeatFrequencyMS controls when the driver checks the state of the MongoDB deployment. Specify the interval (in milliseconds) between checks, counted from the end of the previous check until the beginning of the next one. */\n  heartbeatFrequencyMS?: number;\n  /** Sets the minimum heartbeat frequency. In the event that the driver has to frequently re-check a server's availability, it will wait at least this long since the previous check to avoid wasted effort. */\n  minHeartbeatFrequencyMS?: number;\n  /** The name of the application that created this MongoClient instance. MongoDB 3.4 and newer will print this value in the server log upon establishing each connection. It is also recorded in the slow query log and profile collections */\n  appName?: string;\n  /** Enables retryable reads. */\n  retryReads?: boolean;\n  /** Enable retryable writes. */\n  retryWrites?: boolean;\n  /** Allow a driver to force a Single topology type with a connection string containing one host */\n  directConnection?: boolean;\n  /** Instruct the driver it is connecting to a load balancer fronting a mongos like service */\n  loadBalanced?: boolean;\n\n  /** The write concern w value */\n  w?: W;\n  /** The write concern timeout */\n  wtimeoutMS?: number;\n  /** The journal write concern */\n  journal?: boolean;\n\n  /** Validate mongod server certificate against Certificate Authority */\n  sslValidate?: boolean;\n  /** SSL Certificate file path. */\n  sslCA?: string;\n  /** SSL Certificate file path. */\n  sslCert?: string;\n  /** SSL Key file file path. */\n  sslKey?: string;\n  /** SSL Certificate pass phrase. */\n  sslPass?: string;\n  /** SSL Certificate revocation list file path. */\n  sslCRL?: string;\n  /** TCP Connection no delay */\n  noDelay?: boolean;\n  /** TCP Connection keep alive enabled */\n  keepAlive?: boolean;\n  /** The number of milliseconds to wait before initiating keepAlive on the TCP socket */\n  keepAliveInitialDelay?: number;\n  /** Force server to assign `_id` values instead of driver */\n  forceServerObjectId?: boolean;\n  /** Return document results as raw BSON buffers */\n  raw?: boolean;\n  /** A primary key factory function for generation of custom `_id` keys */\n  pkFactory?: PkFactory;\n  /** A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible */\n  promiseLibrary?: any;\n  /** The logging level */\n  loggerLevel?: LoggerLevel;\n  /** Custom logger object */\n  logger?: Logger;\n  /** Enable command monitoring for this client */\n  monitorCommands?: boolean;\n  /** Server API version */\n  serverApi?: ServerApi | ServerApiVersion;\n  /**\n   * Optionally enable client side auto encryption\n   *\n   * @remarks\n   *  Automatic encryption is an enterprise only feature that only applies to operations on a collection. Automatic encryption is not supported for operations on a database or view, and operations that are not bypassed will result in error\n   *  (see [libmongocrypt: Auto Encryption Allow-List](https://github.com/mongodb/specifications/blob/master/source/client-side-encryption/client-side-encryption.rst#libmongocrypt-auto-encryption-allow-list)). To bypass automatic encryption for all operations, set bypassAutoEncryption=true in AutoEncryptionOpts.\n   *\n   *  Automatic encryption requires the authenticated user to have the [listCollections privilege action](https://docs.mongodb.com/manual/reference/command/listCollections/#dbcmd.listCollections).\n   *\n   *  If a MongoClient with a limited connection pool size (i.e a non-zero maxPoolSize) is configured with AutoEncryptionOptions, a separate internal MongoClient is created if any of the following are true:\n   *  - AutoEncryptionOptions.keyVaultClient is not passed.\n   *  - AutoEncryptionOptions.bypassAutomaticEncryption is false.\n   *\n   * If an internal MongoClient is created, it is configured with the same options as the parent MongoClient except minPoolSize is set to 0 and AutoEncryptionOptions is omitted.\n   */\n  autoEncryption?: AutoEncryptionOptions;\n  /** Allows a wrapping driver to amend the client metadata generated by the driver to include information about the wrapping driver */\n  driverInfo?: DriverInfo;\n\n  /** @internal */\n  srvPoller?: SrvPoller;\n  /** @internal */\n  connectionType?: typeof Connection;\n}\n\n/** @public */\nexport type WithSessionCallback = (session: ClientSession) => Promise<any> | void;\n\n/** @internal */\nexport interface MongoClientPrivate {\n  url: string;\n  sessions: Set<ClientSession>;\n  bsonOptions: BSONSerializeOptions;\n  namespace: MongoDBNamespace;\n  readonly options?: MongoOptions;\n  readonly readConcern?: ReadConcern;\n  readonly writeConcern?: WriteConcern;\n  readonly readPreference: ReadPreference;\n  readonly logger: Logger;\n}\n\n/** @public */\nexport type MongoClientEvents = Pick<TopologyEvents, typeof MONGO_CLIENT_EVENTS[number]> & {\n  // In previous versions the open event emitted a topology, in an effort to no longer\n  // expose internals but continue to expose this useful event API, it now emits a mongoClient\n  open(mongoClient: MongoClient): void;\n};\n\n/** @internal */\nconst kOptions = Symbol('options');\n\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedent over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\nexport class MongoClient extends TypedEventEmitter<MongoClientEvents> {\n  /** @internal */\n  s: MongoClientPrivate;\n  /** @internal */\n  topology?: Topology;\n\n  /**\n   * The consolidate, parsed, transformed and merged options.\n   * @internal\n   */\n  [kOptions]: MongoOptions;\n\n  constructor(url: string, options?: MongoClientOptions) {\n    super();\n\n    this[kOptions] = parseOptions(url, this, options);\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const client = this;\n\n    // The internal state\n    this.s = {\n      url,\n      sessions: new Set(),\n      bsonOptions: resolveBSONOptions(this[kOptions]),\n      namespace: ns('admin'),\n\n      get options() {\n        return client[kOptions];\n      },\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n      get logger() {\n        return client[kOptions].logger;\n      }\n    };\n  }\n\n  get options(): Readonly<MongoOptions> {\n    return Object.freeze({ ...this[kOptions] });\n  }\n\n  get serverApi(): Readonly<ServerApi | undefined> {\n    return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });\n  }\n  /**\n   * Intended for APM use only\n   * @internal\n   */\n  get monitorCommands(): boolean {\n    return this[kOptions].monitorCommands;\n  }\n  set monitorCommands(value: boolean) {\n    this[kOptions].monitorCommands = value;\n  }\n\n  get autoEncrypter(): AutoEncrypter | undefined {\n    return this[kOptions].autoEncrypter;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this.s.readConcern;\n  }\n\n  get writeConcern(): WriteConcern | undefined {\n    return this.s.writeConcern;\n  }\n\n  get readPreference(): ReadPreference {\n    return this.s.readPreference;\n  }\n\n  get bsonOptions(): BSONSerializeOptions {\n    return this.s.bsonOptions;\n  }\n\n  get logger(): Logger {\n    return this.s.logger;\n  }\n\n  /**\n   * Connect to MongoDB using a url\n   *\n   * @see docs.mongodb.org/manual/reference/connection-string/\n   */\n  connect(): Promise<MongoClient>;\n  connect(callback: Callback<MongoClient>): void;\n  connect(callback?: Callback<MongoClient>): Promise<MongoClient> | void {\n    if (callback && typeof callback !== 'function') {\n      throw new MongoInvalidArgumentError('Method `connect` only accepts a callback');\n    }\n\n    return maybePromise(callback, cb => {\n      connect(this, this[kOptions], err => {\n        if (err) return cb(err);\n        cb(undefined, this);\n      });\n    });\n  }\n\n  /**\n   * Close the db and its underlying connections\n   *\n   * @param force - Force close, emitting no events\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  close(): Promise<void>;\n  close(callback: Callback<void>): void;\n  close(force: boolean): Promise<void>;\n  close(force: boolean, callback: Callback<void>): void;\n  close(\n    forceOrCallback?: boolean | Callback<void>,\n    callback?: Callback<void>\n  ): Promise<void> | void {\n    if (typeof forceOrCallback === 'function') {\n      callback = forceOrCallback;\n    }\n\n    const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n\n    return maybePromise(callback, callback => {\n      if (this.topology == null) {\n        return callback();\n      }\n\n      // clear out references to old topology\n      const topology = this.topology;\n      this.topology = undefined;\n\n      topology.close({ force }, error => {\n        if (error) return callback(error);\n        const { encrypter } = this[kOptions];\n        if (encrypter) {\n          return encrypter.close(this, force, error => {\n            callback(error);\n          });\n        }\n        callback();\n      });\n    });\n  }\n\n  /**\n   * Create a new Db instance sharing the current socket connections.\n   *\n   * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n   * @param options - Optional settings for Db construction\n   */\n  db(dbName?: string, options?: DbOptions): Db {\n    options = options ?? {};\n\n    // Default to db from connection string if not provided\n    if (!dbName) {\n      dbName = this.options.dbName;\n    }\n\n    // Copy the options and add out internal override of the not shared flag\n    const finalOptions = Object.assign({}, this[kOptions], options);\n\n    // Return the db object\n    const db = new Db(this, dbName, finalOptions);\n\n    // Return the database\n    return db;\n  }\n\n  /**\n   * Connect to MongoDB using a url\n   *\n   * @remarks\n   * The programmatically provided options take precedent over the URI options.\n   *\n   * @see https://docs.mongodb.org/manual/reference/connection-string/\n   */\n  static connect(url: string): Promise<MongoClient>;\n  static connect(url: string, callback: Callback<MongoClient>): void;\n  static connect(url: string, options: MongoClientOptions): Promise<MongoClient>;\n  static connect(url: string, options: MongoClientOptions, callback: Callback<MongoClient>): void;\n  static connect(\n    url: string,\n    options?: MongoClientOptions | Callback<MongoClient>,\n    callback?: Callback<MongoClient>\n  ): Promise<MongoClient> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    try {\n      // Create client\n      const mongoClient = new MongoClient(url, options);\n      // Execute the connect method\n      if (callback) {\n        return mongoClient.connect(callback);\n      } else {\n        return mongoClient.connect();\n      }\n    } catch (error) {\n      if (callback) return callback(error);\n      else return PromiseProvider.get().reject(error);\n    }\n  }\n\n  /** Starts a new session on the server */\n  startSession(): ClientSession;\n  startSession(options: ClientSessionOptions): ClientSession;\n  startSession(options?: ClientSessionOptions): ClientSession {\n    options = Object.assign({ explicit: true }, options);\n    if (!this.topology) {\n      throw new MongoNotConnectedError('MongoClient must be connected to start a session');\n    }\n\n    return this.topology.startSession(options, this.s.options);\n  }\n\n  /**\n   * Runs a given operation with an implicitly created session. The lifetime of the session\n   * will be handled without the need for user interaction.\n   *\n   * NOTE: presently the operation MUST return a Promise (either explicit or implicitly as an async function)\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An callback to execute with an implicitly created session\n   */\n  withSession(callback: WithSessionCallback): Promise<void>;\n  withSession(options: ClientSessionOptions, callback: WithSessionCallback): Promise<void>;\n  withSession(\n    optionsOrOperation?: ClientSessionOptions | WithSessionCallback,\n    callback?: WithSessionCallback\n  ): Promise<void> {\n    let options: ClientSessionOptions = optionsOrOperation as ClientSessionOptions;\n    if (typeof optionsOrOperation === 'function') {\n      callback = optionsOrOperation as WithSessionCallback;\n      options = { owner: Symbol() };\n    }\n\n    if (callback == null) {\n      throw new MongoInvalidArgumentError('Missing required callback parameter');\n    }\n\n    const session = this.startSession(options);\n    const Promise = PromiseProvider.get();\n\n    let cleanupHandler: CleanUpHandlerFunction = ((err, result, opts) => {\n      // prevent multiple calls to cleanupHandler\n      cleanupHandler = () => {\n        // TODO(NODE-3483)\n        throw new MongoRuntimeError('cleanupHandler was called too many times');\n      };\n\n      opts = Object.assign({ throw: true }, opts);\n      session.endSession();\n\n      if (err) {\n        if (opts.throw) throw err;\n        return Promise.reject(err);\n      }\n    }) as CleanUpHandlerFunction;\n\n    try {\n      const result = callback(session);\n      return Promise.resolve(result).then(\n        result => cleanupHandler(undefined, result, undefined),\n        err => cleanupHandler(err, null, { throw: true })\n      );\n    } catch (err) {\n      return cleanupHandler(err, null, { throw: false }) as Promise<void>;\n    }\n  }\n\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this cluster. Will ignore all\n   * changes to system collections, as well as the local, admin, and config databases.\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n  watch<TSchema = Document>(\n    pipeline: Document[] = [],\n    options: ChangeStreamOptions = {}\n  ): ChangeStream<TSchema> {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new ChangeStream<TSchema>(this, pipeline, resolveOptions(this, options));\n  }\n\n  /** Return the mongo client logger */\n  getLogger(): Logger {\n    return this.s.logger;\n  }\n}\n\n/**\n * Mongo Client Options\n * @public\n */\nexport interface MongoOptions\n  extends Required<\n      Pick<\n        MongoClientOptions,\n        | 'autoEncryption'\n        | 'connectTimeoutMS'\n        | 'directConnection'\n        | 'driverInfo'\n        | 'forceServerObjectId'\n        | 'minHeartbeatFrequencyMS'\n        | 'heartbeatFrequencyMS'\n        | 'keepAlive'\n        | 'keepAliveInitialDelay'\n        | 'localThresholdMS'\n        | 'logger'\n        | 'maxIdleTimeMS'\n        | 'maxPoolSize'\n        | 'minPoolSize'\n        | 'monitorCommands'\n        | 'noDelay'\n        | 'pkFactory'\n        | 'promiseLibrary'\n        | 'raw'\n        | 'replicaSet'\n        | 'retryReads'\n        | 'retryWrites'\n        | 'serverSelectionTimeoutMS'\n        | 'socketTimeoutMS'\n        | 'tlsAllowInvalidCertificates'\n        | 'tlsAllowInvalidHostnames'\n        | 'tlsInsecure'\n        | 'waitQueueTimeoutMS'\n        | 'zlibCompressionLevel'\n      >\n    >,\n    SupportedNodeConnectionOptions {\n  hosts: HostAddress[];\n  srvHost?: string;\n  credentials?: MongoCredentials;\n  readPreference: ReadPreference;\n  readConcern: ReadConcern;\n  loadBalanced: boolean;\n  serverApi: ServerApi;\n  compressors: CompressorName[];\n  writeConcern: WriteConcern;\n  dbName: string;\n  metadata: ClientMetadata;\n  autoEncrypter?: AutoEncrypter;\n  /** @internal */\n  connectionType?: typeof Connection;\n\n  /** @internal */\n  encrypter: Encrypter;\n  /** @internal */\n  userSpecifiedAuthSource: boolean;\n  /** @internal */\n  userSpecifiedReplicaSet: boolean;\n\n  /**\n   * # NOTE ABOUT TLS Options\n   *\n   * If set TLS enabled, equivalent to setting the ssl option.\n   *\n   * ### Additional options:\n   *\n   * |    nodejs option     | MongoDB equivalent                                       | type                                   |\n   * |:---------------------|--------------------------------------------------------- |:---------------------------------------|\n   * | `ca`                 | `sslCA`, `tlsCAFile`                                     | `string \\| Buffer \\| Buffer[]`         |\n   * | `crl`                | `sslCRL`                                                 | `string \\| Buffer \\| Buffer[]`         |\n   * | `cert`               | `sslCert`, `tlsCertificateFile`, `tlsCertificateKeyFile` | `string \\| Buffer \\| Buffer[]`         |\n   * | `key`                | `sslKey`, `tlsCertificateKeyFile`                        | `string \\| Buffer \\| KeyObject[]`      |\n   * | `passphrase`         | `sslPass`, `tlsCertificateKeyFilePassword`               | `string`                               |\n   * | `rejectUnauthorized` | `sslValidate`                                            | `boolean`                              |\n   *\n   */\n  tls: boolean;\n\n  /**\n   * Turn these options into a reusable connection URI\n   */\n  toURI(): string;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}