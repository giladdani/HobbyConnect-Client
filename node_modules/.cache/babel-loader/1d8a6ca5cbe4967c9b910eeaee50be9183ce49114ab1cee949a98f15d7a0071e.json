{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageStream = void 0;\nconst stream_1 = require(\"stream\");\nconst commands_1 = require(\"./commands\");\nconst error_1 = require(\"../error\");\nconst constants_1 = require(\"./wire_protocol/constants\");\nconst compression_1 = require(\"./wire_protocol/compression\");\nconst utils_1 = require(\"../utils\");\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\nclass MessageStream extends stream_1.Duplex {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new utils_1.BufferPool();\n  }\n  _write(chunk, _, callback) {\n    this[kBuffer].append(chunk);\n    processIncomingData(this, callback);\n  }\n  _read( /* size */\n  ) {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const compressorName = operationDescription && operationDescription.agreedCompressor ? operationDescription.agreedCompressor : 'none';\n    if (compressorName === 'none' || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    }\n    // otherwise, compress the message\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n    // Compress the message body\n    compression_1.compress({\n      options: operationDescription\n    }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err || !compressedMessage) {\n        operationDescription.cb(err);\n        return;\n      }\n      // Create the msgHeader of OP_COMPRESSED\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n      msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n      compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n}\nexports.MessageStream = MessageStream;\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !compression_1.uncompressibleCommands.has(commandName);\n}\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n  const sizeOfMessage = buffer.peek(4).readInt32LE();\n  if (sizeOfMessage < 0) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n    return;\n  }\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n  const message = buffer.read(sizeOfMessage);\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n    return;\n  }\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  compression_1.decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err || !messageBody) {\n      callback(err);\n      return;\n    }\n    if (messageBody.length !== messageHeader.length) {\n      callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n      return;\n    }\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","kDefaultMaxBsonMessageSize","kBuffer","Symbol","MessageStream","stream_1","constructor","options","maxBsonMessageSize","utils_1","_write","chunk","_","callback","append","processIncomingData","_read","writeCommand","command","operationDescription","compressorName","agreedCompressor","canCompress","data","toBin","push","Array","isArray","Buffer","concat","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","compression_1","err","compressedMessage","cb","msgHeader","alloc","writeInt32LE","length","requestId","constants_1","compressionDetails","writeUInt8","exports","commandDoc","commands_1","query","commandName","Object","keys","has","stream","buffer","sizeOfMessage","peek","error_1","message","read","messageHeader","responseTo","opCode","ResponseType","messageBody","emit","fromCompressed","compressorID","compressedBuffer"],"sources":["C:\\Users\\danin\\node_modules\\mongodb\\src\\cmap\\message_stream.ts"],"sourcesContent":["import { Duplex, DuplexOptions } from 'stream';\nimport { Response, Msg, BinMsg, Query, WriteProtocolMessageType, MessageHeader } from './commands';\nimport { MongoDecompressionError, MongoParseError } from '../error';\nimport { OP_COMPRESSED, OP_MSG } from './wire_protocol/constants';\nimport {\n  compress,\n  decompress,\n  uncompressibleCommands,\n  Compressor,\n  CompressorName\n} from './wire_protocol/compression';\nimport type { Document, BSONSerializeOptions } from '../bson';\nimport { BufferPool, Callback } from '../utils';\nimport type { ClientSession } from '../sessions';\n\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\nconst kBuffer = Symbol('buffer');\n\n/** @internal */\nexport interface MessageStreamOptions extends DuplexOptions {\n  maxBsonMessageSize?: number;\n}\n\n/** @internal */\nexport interface OperationDescription extends BSONSerializeOptions {\n  started: number;\n  cb: Callback<Document>;\n  command: boolean;\n  documentsReturnedIn?: string;\n  fullResult: boolean;\n  noResponse: boolean;\n  raw: boolean;\n  requestId: number;\n  session?: ClientSession;\n  socketTimeoutOverride?: boolean;\n  agreedCompressor?: CompressorName;\n  zlibCompressionLevel?: number;\n  $clusterTime?: Document;\n}\n\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\nexport class MessageStream extends Duplex {\n  /** @internal */\n  maxBsonMessageSize: number;\n  /** @internal */\n  [kBuffer]: BufferPool;\n\n  constructor(options: MessageStreamOptions = {}) {\n    super(options);\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new BufferPool();\n  }\n\n  _write(chunk: Buffer, _: unknown, callback: Callback<Buffer>): void {\n    this[kBuffer].append(chunk);\n    processIncomingData(this, callback);\n  }\n\n  _read(/* size */): void {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(\n    command: WriteProtocolMessageType,\n    operationDescription: OperationDescription\n  ): void {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const compressorName: CompressorName =\n      operationDescription && operationDescription.agreedCompressor\n        ? operationDescription.agreedCompressor\n        : 'none';\n    if (compressorName === 'none' || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    }\n    // otherwise, compress the message\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n    // Compress the message body\n    compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err || !compressedMessage) {\n        operationDescription.cb(err);\n        return;\n      }\n\n      // Create the msgHeader of OP_COMPRESSED\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(\n        MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\n        0\n      ); // messageLength\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n      msgHeader.writeInt32LE(OP_COMPRESSED, 12); // opCode\n\n      // Create the compression details of OP_COMPRESSED\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n      compressionDetails.writeUInt8(Compressor[compressorName], 8); // compressorID\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n}\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command: WriteProtocolMessageType) {\n  const commandDoc = command instanceof Msg ? command.command : (command as Query).query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream: MessageStream, callback: Callback<Buffer>) {\n  const buffer = stream[kBuffer];\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.peek(4).readInt32LE();\n  if (sizeOfMessage < 0) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(\n      new MongoParseError(\n        `Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`\n      )\n    );\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.read(sizeOfMessage);\n  const messageHeader: MessageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID: Compressor = message[MESSAGE_HEADER_SIZE + 8] as Compressor;\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err || !messageBody) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(\n        new MongoDecompressionError('Message body and message header must be the same length')\n      );\n\n      return;\n    }\n\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}