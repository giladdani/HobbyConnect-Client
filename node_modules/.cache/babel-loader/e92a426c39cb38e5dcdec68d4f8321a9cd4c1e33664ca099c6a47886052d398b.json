{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSharded = exports.applyCommonQueryOptions = exports.getReadPreference = void 0;\nconst common_1 = require(\"../../sdam/common\");\nconst topology_description_1 = require(\"../../sdam/topology_description\");\nconst error_1 = require(\"../../error\");\nconst read_preference_1 = require(\"../../read_preference\");\nfunction getReadPreference(cmd, options) {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary;\n  // If we have an option readPreference override the command one\n  if (options === null || options === void 0 ? void 0 : options.readPreference) {\n    readPreference = options.readPreference;\n  }\n  if (typeof readPreference === 'string') {\n    readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n  }\n  if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n    throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n  }\n  return readPreference;\n}\nexports.getReadPreference = getReadPreference;\nfunction applyCommonQueryOptions(queryOptions, options) {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false\n  });\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n  return queryOptions;\n}\nexports.applyCommonQueryOptions = applyCommonQueryOptions;\nfunction isSharded(topologyOrServer) {\n  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n    return true;\n  }\n  // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n    const servers = Array.from(topologyOrServer.description.servers.values());\n    return servers.some(server => server.type === common_1.ServerType.Mongos);\n  }\n  return false;\n}\nexports.isSharded = isSharded;","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AACA;AACA;AAcA,SAAgBA,iBAAiB,CAACC,GAAa,EAAEC,OAA8B;EAC7E;EACA,IAAIC,cAAc,GAAGF,GAAG,CAACE,cAAc,IAAIC,gCAAc,CAACC,OAAO;EACjE;EACA,IAAIH,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEC,cAAc,EAAE;IAC3BA,cAAc,GAAGD,OAAO,CAACC,cAAc;;EAGzC,IAAI,OAAOA,cAAc,KAAK,QAAQ,EAAE;IACtCA,cAAc,GAAGC,gCAAc,CAACE,UAAU,CAACH,cAAc,CAAC;;EAG5D,IAAI,EAAEA,cAAc,YAAYC,gCAAc,CAAC,EAAE;IAC/C,MAAM,IAAIG,iCAAyB,CACjC,2DAA2D,CAC5D;;EAGH,OAAOJ,cAAc;AACvB;AAnBAK;AAqBA,SAAgBC,uBAAuB,CACrCC,YAA4B,EAC5BR,OAAuB;EAEvBS,MAAM,CAACC,MAAM,CAACF,YAAY,EAAE;IAC1BG,GAAG,EAAE,OAAOX,OAAO,CAACW,GAAG,KAAK,SAAS,GAAGX,OAAO,CAACW,GAAG,GAAG,KAAK;IAC3DC,YAAY,EAAE,OAAOZ,OAAO,CAACY,YAAY,KAAK,SAAS,GAAGZ,OAAO,CAACY,YAAY,GAAG,IAAI;IACrFC,aAAa,EAAE,OAAOb,OAAO,CAACa,aAAa,KAAK,SAAS,GAAGb,OAAO,CAACa,aAAa,GAAG,IAAI;IACxFC,cAAc,EAAE,OAAOd,OAAO,CAACc,cAAc,KAAK,SAAS,GAAGd,OAAO,CAACc,cAAc,GAAG,KAAK;IAC5FC,UAAU,EAAE,OAAOf,OAAO,CAACe,UAAU,KAAK,SAAS,GAAGf,OAAO,CAACe,UAAU,GAAG;GAC5E,CAAC;EAEF,IAAIf,OAAO,CAACgB,OAAO,EAAE;IACnBR,YAAY,CAACQ,OAAO,GAAGhB,OAAO,CAACgB,OAAO;;EAGxC,OAAOR,YAAY;AACrB;AAjBAF;AAmBA,SAAgBW,SAAS,CAACC,gBAAgD;EACxE,IAAIA,gBAAgB,CAACC,WAAW,IAAID,gBAAgB,CAACC,WAAW,CAACC,IAAI,KAAKC,mBAAU,CAACC,MAAM,EAAE;IAC3F,OAAO,IAAI;;EAGb;EACA;EACA,IAAIJ,gBAAgB,CAACC,WAAW,IAAID,gBAAgB,CAACC,WAAW,YAAYI,0CAAmB,EAAE;IAC/F,MAAMC,OAAO,GAAwBC,KAAK,CAACC,IAAI,CAACR,gBAAgB,CAACC,WAAW,CAACK,OAAO,CAACG,MAAM,EAAE,CAAC;IAC9F,OAAOH,OAAO,CAACI,IAAI,CAAEC,MAAyB,IAAKA,MAAM,CAACT,IAAI,KAAKC,mBAAU,CAACC,MAAM,CAAC;;EAGvF,OAAO,KAAK;AACd;AAbAhB","names":["getReadPreference","cmd","options","readPreference","read_preference_1","primary","fromString","error_1","exports","applyCommonQueryOptions","queryOptions","Object","assign","raw","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","session","isSharded","topologyOrServer","description","type","common_1","Mongos","topology_description_1","servers","Array","from","values","some","server"],"sources":["C:\\Users\\danin\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\shared.ts"],"sourcesContent":["import { ServerType } from '../../sdam/common';\nimport { TopologyDescription } from '../../sdam/topology_description';\nimport { MongoInvalidArgumentError } from '../../error';\nimport { ReadPreference } from '../../read_preference';\nimport type { Document } from '../../bson';\nimport type { OpQueryOptions } from '../commands';\nimport type { Topology } from '../../sdam/topology';\nimport type { Server } from '../../sdam/server';\nimport type { ServerDescription } from '../../sdam/server_description';\nimport type { ReadPreferenceLike } from '../../read_preference';\nimport type { CommandOptions } from '../connection';\nimport type { Connection } from '../connection';\n\nexport interface ReadPreferenceOption {\n  readPreference?: ReadPreferenceLike;\n}\n\nexport function getReadPreference(cmd: Document, options?: ReadPreferenceOption): ReadPreference {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || ReadPreference.primary;\n  // If we have an option readPreference override the command one\n  if (options?.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof ReadPreference)) {\n    throw new MongoInvalidArgumentError(\n      'Option \"readPreference\" must be a ReadPreference instance'\n    );\n  }\n\n  return readPreference;\n}\n\nexport function applyCommonQueryOptions(\n  queryOptions: OpQueryOptions,\n  options: CommandOptions\n): CommandOptions {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false\n  });\n\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n\n  return queryOptions;\n}\n\nexport function isSharded(topologyOrServer: Topology | Server | Connection): boolean {\n  if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {\n    return true;\n  }\n\n  // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n  if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {\n    const servers: ServerDescription[] = Array.from(topologyOrServer.description.servers.values());\n    return servers.some((server: ServerDescription) => server.type === ServerType.Mongos);\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}